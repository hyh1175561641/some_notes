


13.5没整理
13.6没整理
13.7没整理

# 账号与群组

用户和用户组:Linux是个多人多用户系统,文件权限是一个非常健全的安全防护措施.为了限制自己,用户组及其他人的使用,Linux有用户和用户组,每一个文件都有三种属性.账号使用一个文件时,先判断自己是否为文件的拥有者,再判断是否是组员,如果都不是,则为其他人.root具有最高权限,可以做任何事情.任何一个文件都具有用户(User),群组(Group),其他人(Others)三种身份的权限
账号可以有多个用户组
用户登录过程: 先寻找passwd文件是否有输入的账号, 然后将账号的UID和GID读取出来, 再读取home目录的配置文件, 接着进入shadow找到UID核对密码, 然后进入shell界面. 黑客会在passwd里面写入账号, 所以要备份passwd和shadow





管理Linux账号和组
```bash
# 当我们登录账号的时候,计算机会识别你的ID
/etc/passwd # 系统上的账号和一般身份用户与root账户
/etc/shadow # 记录了账号的密码,权限是9个-,不给任何人权限
/etc/group # 记录了组名
/etc/gshadow # 组密码
/etc/default/useradd # useradd -D 默认值
/etc/skel/* # 家目录内容复制来源
/etc/login.defs # 密码参数, 里面内容有邮箱目录, shadow密码长度及4/5/6栏, UID/GID限制, 是否建立家目录及权限umask, 密码加密机制(一般是SHA512)
/home/username # 家目录
/var/spool/mail/username # 邮箱地址


man 5 passwd
man 5 shadow

# /etc/passwd 账号名称:密码:UID:GID:使用者说明信息:home目录:Shell
# UID=0系统管理员 =1-999系统账号 =1000+可登入账号
root:x:0:0:root:/root:/usr/bin/zsh
kali:x:1000:1000:,,,:/home/kali:/usr/bin/zsh

# /etc/shadow 账号名称:密码:最近变更密码日期:密码不可更改天数:密码需要重新变更天数:密码需要变更前的警告天数:密码过期后账号宽限时间(密码失效日):账号失效日期:保留(暂时没有任何功能)
# 清空root密码会免密码登录,在密码前面加上!/*会改变密码长度会让密码暂时失效
root:$y$j9T$qFso28Sp1ZaKNME1gSjOA/$Kdqb0V8PZ8NVKp0YsYbQ6FKnRutF4z/j5pjA4w0wCeA:19869:0:99999:7:::
daemon:*:19778:0:99999:7:::
kali:$y$j9T$hW9K52EOJBFsViQ7HRz370$//6l5BWkvHl3PTkK6qgZhGFTLOFKR/zVCEwjlZIwAq0:19778:0:99999:7:::

# /etc/group 群组名称:群组密码:GID:群组支持的账号名称
# 假设想让其他成员加入root组 root:x:0:dmtsai,alex
root:x:0:
kali:x:1000:

# /etc/gshadow 群组名称:群组密码:群组管理员账号:群组支持的账号名称
# 密码栏是!或者空, 不具有群组管理员
# 如果root平时太忙, 那么就会有一个群组管理员来管理自己的小组成员, 现已被sudo取代
root:*::
kali:!::





```

useradd, passwd
```bash

# useradd 新增或者删除使用者
# passwd新增一行账号资料,包括UID/GID/home目录等
# shadow新增密码参数, 但是尚未有密码
# group加入一个与账号名称一模一样的群组名
# /home下建立账号同名的家目录, 权限是700
# -D 显示默认值, 跟/etc/default/useradd相关
# -u 后接UID，直接给定一个账号的UID
# -g 后接初始化群组, 指定群组 GID写入passwd第四栏
# -G 后接加入的群组, 账号可以加入的群组, 写入到group中
# -M 强制执行, 不要建立home目录, 系统账号默认值
# -m 强制执行, 建立home目录, 一般账号默认值
# -c 指定passwd文件第五项内容, 使用者说明信息
# -d 指定某个目录成为home, 不使用默认值, 这里使用绝对路径
# -r 建立一个系统账号, 账号UID会有限制, /etc/login.defs
# -s 后面接一个shell, 默认是/bin/bash
# -e 后面接一个日期, 格式为YYYY-MM-DD, shadow第八栏, 账号失效日期
# -f 后接shadow第七栏, 指定密码是否失效, 0为立刻失效,-1为永不失效, 登录强制重新设定密码
useradd vbird1
ll -d /home/vbird1 # 默认建立家目录, 权限为700, 仅自己能够进入家目录
grep vbird1 /etc/passwd /etc/shadow /etc/group
useradd -u 1500 -g users vbird2 # 指定UID为1500, 初始数组为users
ll -d /home/vbird2 # 成功创建新用户
useradd -r vbird3 # 创建系统账号
ll -d /home/vbird3 # 不会主动创建家目录
useradd -D
GROUP=100 # 初始群为GID为100的组, 但是新版系统使用同名群组作为初始化群组
HOME=/home # 使用者家目录的基本目录(basedir)
INACTIVE=-1 # 密码过期后是否失效默认值
EXPIRE= # 账号失效日期
SHELL=/bin/sh # 默认使用shell程序文件名, 可以设置/sbin/nologin防止登录
SKEL=/etc/skel # 使用者家目录的内容都是这里复制过去的
CREATE_MAIL_SPOOL=no # /var/spool/mail/vbird1 用户的邮箱目录

# passwd 修改用户密码, PAM模块检验密码安全, /etc/pam.d/passwd,pam_cracklib.so
# --stdin 管道输入密码
# -l Lock, 在shadow第二栏前加!, 使密码失效
# -u Unlock, 与-l相反
# -n 天数, shadow第4栏, 多久不修改密码
# -x 天数, shadow第5栏, 多久必须修改密码
# -w 天数, shadow第6栏, 密码过期前的警告天数
# -i 天数, shadow第7栏, 密码失效天数
# -S 列出密码参数
passwd # 修改自己的密码, 输入2次密码即可修改
passwd vbird2 # root账号修改指定用户的密码
echo "abc543CC" | passwd --stdin vbird2
passwd -S vbird2 # 账号名称 状态 密码建立时间 0最小天数 99999变更天数 7提前警告天数 -1不会失效
vbird2 PS 04/25/2024 0 99999 7 -1 # 列出参数
passwd -x 60 -i 10 vbird2 # 60天变更 密码过期10天失效
passwd -S vbird2 # 再次列出参数
vbird2 PS 04/25/2024 0 60 7 10 # 参数变了
passwd -l vbird2 # 账号被锁定, shadow文件第二栏前有!
passwd -u vbird2 # 解锁

# chage 密码参数展示, 比passwd -S更详细
# -l 列出账号详细密码参数
# -d 接日期, 修改第3栏, 最近一次改密码日期, YYYY-MM-DD
# -E 接日期, 修改第8栏, 账号失效日, YYYY-MM-DD
# -m 接天数, 修改第4栏, 密码最短保留天数
# -M 接天数, 修改第5栏, 密码多久需要变更日期
# -W 接天数, 修改第6栏, 密码过期前警告日期
# -I 接天数, 修改第7栏, 密码失效日
chage -l vbird2 # 列出详细信息
useradd agetest; echo "agetest" | passwd --stdin agetest; chage -d 0 agetest; chage -l agetest | head -n 3 # 新建agetest账号, 第一次登录使用默认密码, 但是必须重新设置密码才能进入shell

# usermod 修改用户设置
# -l 后接账号名称, 修改用户名, passwd第1栏
# -u 后接UID, passwd第3栏
# -g 后接初始群组, passwd第4栏GID
# -c 后接账号说明信息, passwd第5栏
# -d 后接账号家目录, 修改passwd第6栏
# -s 后接Shell, 修改passwd第7栏
# -G 后接有效群组, 修改group
# -a 与-G合用, 追加有效群组, 不是修改
# -L 冻结密码, 修改shadow第2栏
# -U 解开密码, 与-L对应
# -f 后接天数, shadow第7栏
# -e 后接日期YYYY-MM-DD, shadow第8栏
usermod -c "VBird's test" vbird2 # 新增说明信息
usermod -e "2015-12-31" vbird2 # 设置失效日期
chage -l vbird2 | grep 'Account expires' # 查看失效日期
ll -d ~vbird3 # 账号没有家目录
cp -a /etc/skel /home/vbird3 # 复制家目录
chown -R vbird3:vbird3 /home/vbird3 # 改拥有者拥有组
chmod 700 /home/vbird3 # 改权限
ll -a ~vbird3 # 家目录内部权限

# userdel 删除账号
# 如果单纯想停用账号直接shadow第8栏设为0, 或者删除passwd和shadow信息, 这个命令其实是删除userdel的所有数据,删除前find / -user username一下确保删干净
# -r 同时删除家目录
userdel -r vbird2

# id 显示当前账号信息
id # 默认显示当前账号的信息
id kali # 显示kali用户的信息

# finger 显示shadow的信息, 危险指令, 默认不安装
# -s 仅列出使用者的账号, 名称, tty和登录时间
# -m 列出指定账号, 而不是账号比较
finger vbird1
Login: vbird1 Name: vbird1 # 使用者账号passwd第1和5栏
Directory: /home/vbird1 Shell: /bin/bash # 家目录和shell
On since Thu May 30 00:56 (CST) on tty2 from tty2 2 hours idle # 登录主机情况
No mail. # 邮箱资料/var/spool/mail
No Plan. # ~vbird1/.plan文件, 读取大概信息
echo "I will study Linux during this year." > ~/.plan # 建立plan, 再次finger vbird1就有信息了
finger # 显示目前系统上使用者的登录时间

# chfn与chsh能够让一般使用者修改passwd文件, SUID功能
# chfn 与finger相关, 给/etc/passwd的第5栏添加说明信息
# -f 接完整大名
# -o 办公室房间号
# -p 办公室电话
# -h 家的电话
chfn # 依次输入全名, 办公室号码,电话,家庭电话, 然后确认密码
finger # 信息更加丰富了

# chsh 修改shell
# -l 列出系统可用的shell, /etc/shells的内容
# -s 修改shell
chsh -l # 列出shell内容
chsh -s /bin/csh; grep vbird1 /etc/passwd # 切换其他shell
chsh -s /bin/bash # 把shell改回来
ll $(which chsh)

# groupadd 新增群组
# -g 后接GID, 直接给定GID
# -r 建立系统群组, /etc/login.defs GID_MIN相关
groupadd group1 # 新增群组
grep group1 /etc/group /etc/gshadow

# groupmod 修改群组参数
# -g 修改GID数字, 最好不要修改, 否则系统会混乱
# -n 修改群组名称
groupmod -g 201 -n mygroup group1 # 改GID和组名

# groupdel 删除群组
groupdel mygroup # 删除群组
groupdel vbird1 # 是某个用户的初始群组, 不能删除

# gpasswd 设置组密码, 群组管理员来替代root账号
# root账号使用的参数
# -A 将群组控制权交给某个用户
# -M 将某些账号加入这个群组中
# -r 将groupname密码移除
# -R 让groupname密码失效
gpasswd groupname
gpasswd -A user1,user2 -M user3,user4 groupname
gpasswd [-rR] groupname
# 群组管理员的参数
# -a 把用户加入到群组中
# -d 把用户移除出群组
gpasswd [-ad] user groupname
# 示范
groupadd testgroup # 建立群组
gpasswd testgroup # 给定密码
gpasswd -A vbird1 testgroup # 添加群组管理员
gpasswd -a vbird1 testgroup # 切换成群组管理员账号,添加新组员

# groups 查看有效群组
# 进入系统写在passwd第四栏的是初始群组, 通过读取group文件后来添加的群组叫有效群组
# newgrp 切换有效群组
groups # 有效群组是 kali wheel users
touch test1 # 拥有群组是kali
newgrp users # 切换了有效群组, 必须是groups命令里支持的群组, 这里使用新shell登录重新设定群组权限
groups # 有效群组是 users wheel kali
touch test2 # 拥有组是users
exit # 对应上面的newgrp命令, 退出后有效组还原

```

ACL(Access Control List)针对某个用户设定的特殊权限需求
ACL因为Linux的需要, 成为了Linux默认套件, 支持Ext2/3/4/xfs

```bash
dmesg | grep -i acl # 检查内核挂载信息

# setfacl 设定目录或文件ACL规则
# -m 设置后续的acl参数给文件使用, 不可与-x合用
# -x 删除后续的acl参数, 不可与-m合用
# -b 移除所有的acl参数
# -k 移除默认的acl参数
# -R 递归设定acl, 子目录都设置
# -d 设置默认acl参数, 只对目录有效, 新建的子目录使用此默认值
# getfacl 获取目录或文件ACL设置的项目
# 参数与setfacl相同
touch acl_test1
ll acl_test1
setfacl -m u:vbird1:rx acl_test1 # 针对某个用户的规则
ll acl_test1
setfact -m u::rwx acl_test1 # 默认修改使用者用户权限
ll acl_test1
getfacl acl_test1 # 查看acl权限
setfacl -m g:mygroupl:rx acl_test1 # 修改组权限
getfacl acl_test1
# mask权限是有效权限, 如果mask是r--, acl针对特殊用户的文件权限是r-x, 则x不会生效, mask规定最大允许的权限
setfacl -m m:r acl_test1 # 设置mask, 在有效权限内才会生效
getfacl acl_test1
setfacl -m d:u:myuser1:rx /srv/projecta # 新建文件默认权限值
getfacl /srv/projecta # 建立子文件和目录会有默认权限值

setfacl -x u:myuser1 /srv/projecta # 取消某个用户的acl
setfacl -x d:u:myuser1 /srv/projecta # 取消用户的默认acl
setfacl -m u:pro3:- /srv/projecta # 让pro3无法查看该目录


```

su sudo visudo
```bash

# su 切换账号
# - 以login-shell变量方式登入系统
# -l 与-类似, 后面需要加使用者账号
# -m 同-p, 使用目前的环境设置, 不读取新使用者的设定
# -c 仅进行一次指令, 后加需要执行的指令
su # 默认切换成root账户, 输入root密码, 环境变量依然不变
env | grep 'kali' # 环境变量依然不变
su - # 切换root账户, 以login-shell方式登录
env | grep 'root' # root默认的环境变量
su - -c "head -n 3 /etc/shadow" # 用root执行一次命令
su kali1 # 切换普通用户, 输入普通用户密码
su -l vbird1 # 完整地切换为其他用户

# sudo 以root身份来执行命令, 仅仅需要自己的密码, 只有规定到/etc/sudoers内的用户才能执行sudo指令
# sudo指令时间间隔超过5分钟需要重新输入密码, 连续使用只需第一次输密码
# -b 将命令放到后面执行, 而不是在前面shell产生影响
# -u 后接切换的使用者, 默认root
sudo -u sshd touch /tmp/mysshd # 以sshd身份创建文件, 这个账号无法登录
sudo -u vbird1 sh -c "mkdir ~vbird1/www; cd ~vbird1/www; echo 'This is index.html file' > index.html"
ll -a ~vbird1/www # 拥有者和拥有组是vbird1

# visudo 用该指令修改/etc/sudoers会进行限制和语法检测
visudo # 使用root修改文件, 某个账号可以使用root所有指令
root ALL=(ALL) ALL # 账号 可下达指令的主机名称(可切换的身份) 可下达的指令
vbird1 ALL=(ALL) ALL # 添加新账号
visudo # 用户加入群组可以使用sudo
%wheel ALL=(ALL) ALL # wheel群组前加%, 进群的用户可以使用sudo
%wheel ALL=(ALL) NOPASSWD: ALL # 不需要密码即可使用sudo
usermod -a -G wheel pro1 # 将pro1加入wheel群组, 可以使用sudo
visudo # 仅能修改有限的指令
myuser1 ALL=(root) /usr/bin/passwd # 使用绝对路径指定有效指令
myyser1 ALL=(root) !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root # 限制不能修改root的密码
visudo # 设置命令别名
User_Alias ADMPW = pro1, pro3, myuser1, myuser2
Cmd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root # 命令别名
ADMPW ALL=(root) ADMPWCOM
visudo # sudo搭配su使用
User_Alias ADMINS = pro1, pro2, pro3, myuser1
ADMINS ALL=(root) /bin/su -




```bash
# 外部身份登录系统
Active Directory(AD)

LDAP
NIS

authconfig-tui



```







# 文件权限属性



Linux文件权限的重要性,文件权限最大重要性的是在数据安全性上面.可以保护系统功能,防止系统文件被修改或删除.可以团队协同开发.可以防止不明人士捣乱

目录与文件的权限意义不同,对于目录来说,可读代表目录下的文件,可写代表新建删除重命名目录下的文件,可执行代表可以切换工作目录,目录与文件权限的意义
文件权限：文件是实际含有数据的地方,包括一般文本文件,数据库文件,二进制可执行文件(binary program)等.
r(read)可读取此文件的实际内容,如读取文本文件的文字内容
w(write)可以写入编辑新增或修改文件的内容,代表删除部分内容,但不代表删除文件本身
x(execute)该文件具有可被系统执行的权限
文件权限---,不能查看,不能修改,不能执行,但是可以删除这个文件
目录权限：目录主要的内容在记录文件名列表,文件名与目录有强烈的关联
r(read contents in directory)表示具有读取目录结构列表的权限,ls命令
w(modify contents in directory)表示具有改动目录结构列表的权限,与该目录下的文件名变动有关.建立新文件或目录,删除文件或目录,重命名文件或目录,移动该目录内的文件、目录位置
x(access directory)表示用户能否进入该目录成为工作目录,cd命令.
注意: 要开放目录给任何人浏览时,至少要有rx权限,w权限谨慎开放,只有r权限时,ls -al可查询文件名,文件属性无法查看
目录权限r--,仅能查看目录内容,不能cd,不能删除目录下的内容
如果提示permission deny,权限设置错误.不论用户组是什么,账号是最主要的主角

```bash

ls # 显示目录内容list,默认显示非隐藏文件,以文件名排序,显示颜色
# ls [-alrtAFR] [name...] # 显示文件列表
# -a 显示所有的文件和目录,包括名称开头为"."的隐藏档
# -A 同-a,但是不列出"."和".."(当前目录和父目录)
# -d 仅显示目录名,而不显示目录下的内容列表.显示符号链接文件本身,而不显示其所指向的目录列表
# -f 直接列出结果,不进行排序
# -F 在列出的文件名称之后加一个符号,可执行档加"*",目录加"/",socket文件加=,FIFO文件加|
# -h 按照人类阅读的单位显示大小
# -i 显示目录的inode
# -l 将文件形态、权限、拥有者、文件大小的详细列表列出
# -n 用户名和组名用UID和GID显示出来
# -r 将文件以相反的次序显示(默认次序是英文字母次序)
# -R 若目录下有文件夹,所有文件夹的所有文件都列出
# -S 按照文件容量大小排序,不以文件名排序
# -t 将文件依建立时间先后次序列出
# --color= never不显示颜色 always显示颜色 auto自行判断颜色
# --full-time 列出完整的时间格式,包括年月日时间和时区
# --time={atime,ctime} 输出access时间或改变权限属性时间ctime而不是内容更改时间modification time
# --help 帮助
ls -al # 当前目录下的所有文件的详细信息
ls -alF --color=never # 不显示颜色
ls -al --full-time # 显示详细时间
ls -lSr # 最大的文件排在最下面,方便查看

[root@ubuntu /]# ls -al
total 68
dr-xr-xr-x. 18 root root  4096 Dec 15 02:11 .
dr-xr-xr-x. 18 root root  4096 Dec 15 02:11 ..
drwxr-xr-x. 79 root root  4096 Dec 17 03:48 etc
drwxr-xr-x.  3 root root  4096 Dec 15 12:24 home
drwxr-xr-x. 19 root root  4096 Oct  8 09:17 var
# 权限drwxr-xr-x. 链接19 拥有者root 用户组root 文件容量4096 日期Oct  8 09:17 文件名var
# 第一列是文件的类型与权限,共有十个字符
# 第一个字符是指文件的类型
# d 目录
# - 常规文件(纯文本文件,可以直接读取,二进制文件,系统仅认识的文件,数据文件,特定格式的文件
# l 链接,一般是软链接
# b 块设备文件,可供存储的周边设备,随机存取的接口设备./dev目录下,如/dev/sda
# c 字符设备文件,串行端口设备,一次性读取,不能截断输出.列如键盘,鼠标,/dev目录下
# s 套接字文件,通常用在网络数据连接,服务器监听,客户端就可以通过这个接口进行数据沟通,最常在/var/run目录中看到
# p 管道文件,特殊的文件类型,解决多个程序同时存取一个文件所造成的错误.FIFO是first-in-first-out(先进先出)的缩写

# 接下来的九个字符,三个为一组,代表文件的权限,第一组是文件拥有者的权限,第二组是加入用户组,第三组是其他账号,三组都是rwx组合,r(read)代表可读,w(write)代表可写,x(execute)代表可执行,如果没有权限则出现[-]
# 第二列代表有多少文件名链接到此节点(inode),这是硬链接与第一个l字符不同
# 第三列表示这个文件拥有者的账号
# 第四列表示这个文件的所属用户组
# 第五列表示这个文件的容量大小,默认单位为Bytes
# 第六列表示这个文件的最近修改日期
# 第七列显示文件名,点开头的是隐藏文件



```


每个文件都具有拥有人和拥有组,文件属性记录的是数字,显示文件属性时,系统根据/etc/passwd和/etc/group的内容显示出来,如果查询不到,文件属性直接显示一个数字
每个登录的用户至少都有两个ID,一个是用户ID(User ID,UID),一个是用户组ID(Group ID,GID)
```bash
# 文件属性会记录UID而非用户名称, 正式系统禁止尝试, 万一程序崩掉呢
id kali
ls -l -d /home/kali # 显示目录权限
vim /etc/passwd # 强制修改kali用户的UID
ls -l -d /home/kali # 可以看到所有者变成数字而非kali
vim /etc/passwd # 还原kali的用户UID
```

修改文件权限
```bash
# 若要修改文件的第一列权限,第三列拥有者,第四列用户组,使用下面三个命令

# chmod 修改文件的权限,SUID、SGID、SBIT等特性
# chmod 数字修改法,r用4代表,w用2代表,x用1代表
# chmod 符号修改法,u代表用户 g代表组 o代表其他 a代表所有,rwx代表要改变的权限,+加入 -移除 =设置
# -R 进行递归修改,将目录下的所有子文件子目录都更新
chmod 755 test.sh # 执行文件,其他人可以运行但不能修改
chmod 740 text.sh # 不希望其他人看到
chmod 664 text.txt # 普通文本文件,可修改,其他人只能阅读
chmod u=rwx go=rx test.sh # 执行文件,可修改可执行,其他人不能修改
chmod a+w text.txt # 所有人可写入
chmod a-x test.sh # 所有人都不可执行

# chown 修改文件的拥有者,账号必须是/etc/passwd已经存在的,还可以顺便修改用户组(change owner)
# -R 进行递归修改,将目录下的所有子文件子目录都更新为这个拥有者
chown ownername file
chown ownername:groupname file # 冒号,修改拥有者和用户组
chown ownername.groupname file # 小数点修改拥有者和用户组

# chgrp 修改文件的用户组,用户组必须是/etc/group已经存在的(change group)
# -R 进行递归修改,将目录下的所有子文件子目录都更新为这个用户组
chgrp groupname file


```


文件与目录的默认权限与隐藏权限
```bash

# umask 当前目录创建文件的默认权限,默认要减掉的分数权限,配置文件参考/etc/bashrc
# 数字的后三个002表示拿掉权限 --- --- -w-,本质是位运算
# 建立文件权限 (-rw-rw-rw-)-(-------w-)==> (-rw-rw-r--)
# 建立目录权限 (drwxrwxrwx)-(-------w-)==> (drwxrwxr-x)
umask # 数字型态权限分数 0002,一般用户是002,root用户是022
umask -S # 符号类型显示权限
touch test1 # 默认-rw-rw-r--
mkdir test2 # 默认drwxrwxr-x
ll -d test* # 查看目录时看目录本身的属性

# chattr 设置隐藏属性,只能在EXT234文件系统上完整生效,其他无法完全有效
# + 增加特殊参数,其他原本的参数不变
# - 移除特殊参数,其他参数不变
# = 设定确定的参数,且仅有后面接的参数
# A 如果读取这个文件或目录,atime不变,避免读写速度较慢的机器读取磁盘,建议文件系统挂载项目处理这个项目
# S 加上这个参数,对文件进行更改,同步写入磁盘,一般文件非同步写入磁盘
# a 这个文件只能增加内容,不能删除不能修改,仅root才能设定这个属性
# c 自动压缩文件,读取时自动解压缩,储存的时候,进行压缩再储存
# d 当dump程序被执行时,设定d属性不会被dump备份
# i 文件不能删除重命名设定链接也无法写入修改内容,只有root能设定此属性
# s 如果文件被删除,将会完全移除出这个磁盘空间,一旦误删,再也找不回来了
# u 如果文件被删除,内容还保留再磁盘中,可以用工具来救援
# 常用的值是ai,许多只能由root设定,XFS文件系统只支持AadiS
touch attrtest # 新建文件
chattr +i attrtest # 加入i属性
rm attrtest # 无法删除
chattr -i attrtest # 取消掉这个属性

# lsattr 显示文件的隐藏属性
# -a 显示所有文件和目录,包括隐藏目录
# -d 接的是目录,仅列出目录本身的属性,而不是目录内的文件名
# -R 连同子目录的资料也一并列出来
chattr +aiS attrtest # 加上隐藏属性
lsattr attrtest # 列出文件的隐藏属性

```



当文件的使用者权限x变成s时, 被称为Set UID, 简称为SUID特殊权限. 可以使普通用户执行的程序具有root权限. 主要有几条限制, 仅对二进制程序有效, 执行者要有x权限, 仅在执行过程中有效, 执行者是程序的拥有者. 比如passwd程序就可以以普通用户身份修改/etc/shadow文件
当文件或目录的用户组权限x变成s时, 被称为Set GID, SGID. 有几条限制, 对二进制程序有用, 程序执行者有x权限, 执行者在程序运行中会获得群组支持. 对于目录, 使用者对目录有rx权限则可以进入此目录, 使用者在此目录下的有效群组将会变成该目录的群组. 如果使用者在此目录下具有w权限, 则使用者新建文件的群组和此目录的群组相同.
Sticky Bit, SBIT. 只针对目录有效, 当使用者对此目录具有wx(写入)权限,使用者在目录下建立文件或目录时,仅有自己与root才有权利删除该文件. 在/tmp目录下所有人都能增加修改, 但是仅有文件或目录的建立者与root能够删除自己的文件或目录


```bash

# 观察发现
ls -l /usr/bin/passwd # SUID -rwsr-xr-x
ls -l /usr/bin/locate # SGID -rwx--s--x
ls -ld /tmp # SBIT drwxrwxrwt

# SUID=4 SGID=2 SBIT=1
# SUID=u+s SGID=g+s SBIT=o+t
cd /tmp
touch test
chmod 4755 test; ls -l test # 添加SUID功能
chmod 7666 test; ls -l test # -rwSrwSrwT 大写表示具有空的SUID/SGID功能
chmod u=rwsx,go=x test; ls -l test # -rws--x--x 设置SUID
chmod g+s, o+t test; ls -l test # -rws--s--t 添加SGID SBIT

passwd # 普通用户执行, 然后Ctrl-z 暂停工作
pstree -uA # 观察到passwd的拥有者变成了root



```



# 目录与文件

Linux文件名最长255字节,中文符号占用2个字节,避免使用特殊符号*?><;&![]|\'"`(){}-+,以点开头的文件是隐藏文件

Linux文件拓展名与属性无关,但是仍然借助拓展名可以了解该文件是什么种类：.sh是脚本或批处理文件..Z .tar .tar.gz .zip .tgz是经过打包的压缩文件(gunzip,tar等),.html.php是网页文件.文件属性与权限有关.文件通过网络传输,可能会丢失权限属性.

文件种类
正规文件(regular file), 文字文件(ASCII), 二进制文件(binary), 资料格式文件(data)
目录(directory)
链接文件(link)
设备文件(device), 块设备文件(block), 字符设备文件(character)
套接字文件(sockets)
管道文件(FIFO, pipe)

目录树
在Linux下面,所有文件与目录都是由根目录开始的,然后一个一个的分支下来,像是一个树的形状.因此我们称这种目录配置方式为目录树(directory tree).
目录树的起始点是根目录(/,root),每一个目录不止能使用本地分区的文件系统,也可以使用网络上的文件系统.比如,可以使用NFS(Network File System)服务器挂载某特定目录等,每一个文件在此目录树的文件名(完整路径)都是独一无二的

根据文件名写法不同,可分为相对路径(relative)与绝对路径(absolute)
绝对路径：由根目录(/)开始写起的文件名或目录名称,这样对强调文件名的准确性比较好(写脚本,计划任务at,cron的时候用)
相对路径：相对于当前路径的文件名写法,是以当前所在路径的相对位置来表示的

一个点.代表当前的目录,也可以用./来表示
两个点..代表上一层的目录,也可以../来表示
小横杠-代表前一个工作目录
波浪线~代表当前使用者身份所在的家目录
~account代表account这个使用者的的家目录


```bash
# 文件操作命令

# file 查看文件的类型
file /bin/bash # 查看文件是否为可执行文件
file /etc/init.d/network # bash shell文件,ASCII文本文件
file /var/lib/mlocate/mlocate.db # 数据文件

# basename 获取文件名
# dirname 获取目录名
basename /var/log/dmesg # dmesg 获取文件名
dirname /var/log/dmesg # /var/log 获取目录名


# cp 复制文件,copy的缩写,还可以建立链接,复制整个目录,如果源文件有多个,最后的目标必须是目录
# -a 等于-dr --preserve=all
# -d 如果源目录是链接link file,则复制链接而不是目录本身
# -f 强制force,如果目标文件已存在但无法开启,请移除后再试一次
# -i 如果目标文件destination已经存在,在覆盖时会提出询问
# -l 复制一个硬链接,不复制文件本身
# -p 同文件本身的属性(权限,用户,时间)一起复制,不使用默认属性
# -R/r 递归处理,将指定目录下的所有文件与子目录一并处理；
# -s 复制为软链接symbolic link
# -u 目标文件不存在或比源文件旧才能更新
# --preserve=all 除了-p权限相关参数外,还包括SELinux属性,links,xattr等也进行复制
# --help
cp source.txt destination.txt # 复制文件,复制时权限和所有者及其他属性可能发生改变
cp -R 源目录 目标目录 # cp不能复制目录,必须加-R选项
cp -a /var/log/wtmp wtmp2 # 文件的内容和属性完全一样,备份重要文件用这个
cp -r /etc /tmp # 复制目录,或者使用-a更安全
cp -l text hlink # 硬链接
cp -s text slink # 软链接
cp -d slink slink2 # 复制软链接,如果不加d,复制的是文件本身,
cp -u ~/.bashrc /tmp/bashrc # 目标文件比源文件时间早则复制,常用做备份
cp text1 text2 text3 /tmp # 复制多个文件,最后一定是目录
cp -a /var/log/wtmp /tmp/dmtsai_wtmp # 源文件的所有者和群组无法复制过来

# rm 删除,remove的缩写
# -f force的意思,忽略不存在的文件,不会出现警告信息
# -i 删除前进行询问
# -r 递归处理,删除所有目录和文件
rm -i bashrc # 互动模式,删除之前提问
rm -i bashrc* # 删除批量文件
rm ./-aaa- # -会被误识别为参数,所以加上路径

# mv 移动,move的缩写
# -f force强制的意思,如果目标文件已存在,不会询问直接覆盖
# -i 如果目标文件已经存在,询问是否覆盖
# -u 如果目标文件已存在,且source较新,才会更新
mkdir testdir # 创建新目录
mv test testdir # 移动文件到目录中
mv test1 test2 # 更新文件名,同效命令rename
mv test1 test2 test3 testdir # 如果移动多个文件,最后一个必须是目录

# modification time(mtime): 当文件内容更新时,就会更新这个时间,文件内容并非指文件的属性和权限
# status time(ctime): 当文件状态改变时,更新这个时间,文件的权限和属性改变会更新这个时间
# access time(atime): 当文件内容被读取时,更新这个时间,如cat命令

# touch 新建文件,修改文件时间,ctime属性没办法复制和修改,mtime与atime容易变动
# -a 仅修改access time
# -c 仅修改文件时间,如果文件不存在则不建立新文件
# -d 后面可以接欲修改的日期而不用目前的日期,也可使用--date="日期或时间"
# -m 仅修改mtime
# -t 后面可以接欲修改的时间而不用目前的时间,格式为YYYYMMDDhhmm
data; # 当前时间 
ls -l /etc/man_db.conf; # 默认显示mtime
ls -l --time=atime /etc/man_db.conf; # atime
ls -l --time=ctime /etc/man_db.conf; # ctime
touch test # 创建新文件,如果文件存在,则三个时间都会变成当前时间
ls -l test # 文件大小为0
cp -a ~/.bashrc bashrc # 复制完整的属性,包括时间属性mtime
date; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc # mtime被复制
touch -d "2 days ago" bashrc # atime,mtime变成两天前,ctime不变
touch -t 201406150202 bashrc # atime,mtime改变,ctime不变



```


```bash
# 目录操作命令
# cd 切换目录,是change directory的缩写
cd 绝对路径或相对路径
cd # 回到家目录
cd ~ # 回到家目录
cd ~account # 切换到account目录
cd . # 当前目录
cd .. # 上级目录
cd - # 上次的目录
cd /var/spool/mail # 绝对路径
cd ../postfix # 相对路径，必须确认当前目录正确才能进行切换

# pwd 显示当前目录, Print Working Directory的缩写
# -P 显示确切的路径,而不是链接路径
cd /bin
pwd # 显示链接/bin
pwd -P # 显示真实路径/usr/bin

# mkdir 建立一个新目录, make directory的缩写
# -m 设定目录的权限,不受默认权限umask的影响
# -p 递归操作,将上层目录连续建立起来
mkdir test
mkdir -p test1/test2/test3/test4 # 创建连续目录
mkdir -m 711 test2 # 设定test2目录的权限

# rmdir 删除一个空目录,
# -p 递归操作,连同路径中的父目录一同删除
# -v 输出信息
rmdir -p test1/test2/test3/test4

```




```bash
# 文件查找命令,一般使用whereis和which查询文件,find比较耗费磁盘性能

# which 寻找PATH下可执行文件
# -a 将所有PATH查找到的指令全列出来,而不是第一个查到的指令名称
which ifconfig # 搜索完整路径
which ls # 别名和路径名
which history # bash内置的命令无法找到

# whereis
# -l 列出whereis会去查询的几个主要目录
# -b 仅查询binary格式的文件
# -m 仅查询manual下的文件
# -s 只查询source来源文件
# -u 搜索不属于上面三类的文件
whereis ifconfig # 查找文件名
whereis passwd # 查找所有的oasswd文件
whereis -m passwd # 查找man里面的文件名
where -l # 显示查找范围

# locate/updatedb 查询文件的部分字母就能查询到结果,通过/var/lib/mlocate建立的内容库查找到的
# 通过updatedb命令寻找/etc/updatedb.conf更新库,然后才能查询到
# -i 忽略大小写
# -c 不输出文件名,仅列出文件总数
# -l 输出几行,如-l 5 是输出5行
# -S 输出locate
# -r 后接正则表达式
locate -l 5 passwd # 查询到结果前5行passwd内容
locate -S # 显示信息
ls -ld $(locate crontab) # 查询文件的权限


# find 查找硬盘上的文件
# -atime -ctime -mtime 与时间相关
# -mtime n 在n天前的一天之内被更改过的内容(今天6号,列出3号那一天的改动过的文件)
# -mtime +n 列出n天之前(不含n天)被更改过的内容(今天6号,列出3号之前改动过的文件)
# -mtime -n 列出n天之内(含n天)被更改过的内容(今天6号,列出3-6号改动过的文件)
# -newer file file为一个存在的文件,列出比file还要新的文件名
find / -mtime 0 # 列出过去24小时内被更改过的文件
find /etc -newer /etc/passwd # 比passwd文件更新的文件

# 与用户和群组相关的参数,安装第三方软件时,就很有可能存在无法识别的用户名和组名的文件.假设你的系统是自己编译的,那么可能会输出一堆文件.假设某个账户被删除了,那么就会有很多用户未知的文件
# -uid n n表示UID用户ID,记录在/etc/passwd里面与账号对应的数字
# -gid n n表示GID组ID,记录在/etc/group里
# -user name name为用户名称
# -group name name为组名称
# -nouser 查询/etc/passwd里用户不存在的人
# -nogroup 查询/etc/group里组名不存在的人
find /home -user ubuntu # /home目录下查询ubuntu用户的文件
find / -nouser # 查询用户未知的文件

# 与文件权限和名称有关的参数
# -name filename 查询文件名为filename的文件
# -size [+-]SIZE 查询比SIZE还要大或小的文件,单位c表示byte,k表示1024byte,M表示1024k
# -type TYPE 指定文件类型TYPE,普通文件f,设备文件bc,目录d,链接文件l,socket文件s,FIFO文件p
# -perm mode 查询属性值等于指定值的文件,如等于 4755-rwsr-xr-x
# -perm -mode 查询属性值必须包括指定值的文件,如必须包括0744 -rwxr--r--
# -perm /mode 查询属性值包含任一值的文件,如搜索0744-rwxr-xr-x,-rw-------也符合
find / -name passwd # 查找名为passwd的目录
find / -name "*passwd*" # 包含passwd的文件
find /run -type s # 查询/run目录下文件类型为Socket的文件名
find /root -size +50k # 查找比50k还要大的文件
find / -perm /7000 # 搜索含有SUID,SGID,SBIT属性的文件
find /usr/bin /usr/sbin -perm /6000 # 查询/usr/bin,/usr/sbin下的具有SUID,SGID的二进制可执行文件

# 其他参数
# -print 打印信息到屏幕上,默认会有这个功能
# -exec command command为其他指令,-exec后面可再接额外的指令来处理查询到的结果
find /usr/bin /usr/sbin -perm /7000 -exec ls -l {} \; # 只能使用ls,这里不支持别名
# {}表示find查询到的结果,把结果放到这个位置里
# -exec到\这里,代表find额外动作的开始与结束,中间是其他指令
# ;在bash环境下是有特殊意义的,因此用反斜线来转义

find / -perm /6000 # 查询系统上的SUID/SGID文件






```




# Linux目录配置FHS
FHS标准说明
wiki http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard
FHS2.3 2004年 http://www.pathname.com/fhs/pub/fhs-2.3.html
FHS3.0 2015年 http://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf
https://blog.csdn.net/unforgettable2010/article/details/123931966?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167259530516800184160029%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167259530516800184160029&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-123931966-null-null.142^v68^wechat,201^v4^add_ask,213^v2^t3_esquery_v3&utm_term=%2Fusr%2Fshare%2Fdoc&spm=1018.2226.3001.4187 CentOS下的目录及其作用

FHS (Filesystem Hierarchy Standard) ,文件系统层次标准,Linux目录配置方法
每个独立的软件开发商,操作系统制作者以及想要维护系统的用户,都能遵循FHS标准.FHS重点在于规范每个特定的目录下应该要放置什么样的数据.
FHS依据文件系统使用是否频繁和是否允许用户随意更改,将目录定义成四种交互作用的形态

使用是否频繁    可分享(shareable)        不可分享(unshareable)
不变static     /usr(软件存放处)          /etc(配置文件)
               /opt(第三方辅助软件)      /boot(启动与内核文件)
可变动variable /var/mail(用户邮箱)       /var/run(程序相关)
               /var/spool/news(新闻组)   /var/lock(程序相关)

可分享：可以分享给其他系统挂载使用的目录,是能够分享给网络上其他主机挂载用的目录,包括执行文件与用户的邮件等数据
不可分享：自己机器上面运行的设备文件或是与程序有关的socket文件等,仅与自身机器有关,不适合分享给其他主机
不变：有些数据不会经常变动,跟随发行版而不变动.如函数库,文件说明,系统管理员管理的主机服务配置文件等
可变动：经常修改的数据,列如日志文件,一般用户可自行接收的新闻组等

FHS针对目录树架构仅仅定义了这三个目录下放置的数据,这三个分别是：
/(root,根目录)：与启动系统有关
/usr (Unix software resource)：与软件安装/执行有关
/var (variable)：与系统运行过程有关

/根目录下的内容

根目录不仅衍生出来了所有的目录,同时根目录也与启动、还原、系统修复等操作有关.由于系统启动时需要特定的启动软件、内核文件、启动所需的程序、函数库等文件数据,若系统出现错误时,根目录也必须要包含有能够修复文件系统的程序才行.因此FHS标准建议：根目录所在分区应该越小越好,且应用程序所安装的软件最好不要与根目录放在同一个分区内,保持根目录越小越好.这样不但性能较佳,根目录所在的文件系统也较不容易发生问题

FHS定义根目录下必须要有下面这些目录,即使没有物理目录,也至少要有链接(link)目录.

FHS要求必须要存在的目录

/bin系统有很多存放执行文件的目录,但/bin比较特殊.因为/bin放置的是在单人维护模式下还能够被使用的命令.在/bin下面的命令可以被root与一般账号所使用,主要有：cat、chmod、chown、date、mv、mkdir、cp、bash等常用的命令
/boot这个目录主要在放置启动会使用到的文件,包括Linux内核文件以及启动选项与启动所需配置文件等.Linux内核常用的文件名为：vmlinuz,如果使用的是grub2这个启动引导程序,则还会存在/boot/grub2/这个目录
/dev在Linux系统上,任何设备与接口设备都是以文件的形式存在于这个目录当中.只要你通过读写这个目录下面的某个文件,就等于读写某个设备,比较重要的文件有/dev/null、/dev/zero、/dev/tty、/dev/loop*、/dev/sd*等
硬件装置的文件名,IDE接口的磁碟之后被模拟成/dev/sd[a-p] https://www.kernel.org/doc/html/v4.20/admin-guide/devices.html
/dev/sd[a-d] 硬盘文件名 SCSI/SATA接口 USB光驱
/dev/sd[a-p] U盘
/dev/vd[a-p] 虚拟机内的 VirtI/O接口 云服务器可能这样
/dev/fd[0-1] 软盘
/dev/lp[0-2] 25针打印机
/dev/usb/lp[0-15] USB接口
/dev/input/mouse[0-15] 通用鼠标
/dev/psaux PS/2接口
/dev/mouse 当前鼠标
/dev/scd[0-1] 通用 CDROM/DVDROM
/dev/sr[0-1] 通用 CDROM/DVDROM
/dev/cdrom 当前CDROM/DVDROM
/dev/ht0 IDE接口 磁带机
/dev/st0 SATA/SCSI接口 磁带机
/dev/tape 当前 磁带机
/dev/hd[a-d] IDE硬碟机

/etc系统主要的配置文件几乎都放在这个目录内,例如人员的账号密码文件、各种服务的启动文件等.一般来说,这个目录下的各文件属性是可以让一般用户查看的,但是只有root有权利修改.FHS建议不要放置可执行文件在这个目录.比较重要的文件有：/etc/modprobe.d/、/etc/passwd、/etc/fatab、/etc/issue等.另外FHS还规范几个重要的目录最好要存在/etc/目录下: /etc/opt(必要)：这个目录在放置第三方辅助软件/opt的相关配置文件./etc/X11/(建议)：与X Window有关的各种配置文件都在这里,尤其是xorg.conf这个X Server的配置文件./etc/sgml/(建议)：与SGML格式有关的各项配置文件./etc/xml/(建议)：与XML格式有关的各项配置文件.
/lib系统的函数库非常多,而/lib放置的则是在启动时会用到的函数库,以及在/bin或/sbin下面的命令会调用的函数库而已.什么是函数库？你可以将它想成是外挂,某些命令必须要有这些外挂才能够顺利完成程序的执行之意,另外FSH还要求下面的目录必须要存在：/lib/modules/:这个目录主要放置可抽换式的内核相关模块(驱动程序)
/media是媒介的英文,顾名思义,这个/media下面放置的就是可删除的设备,包括软盘,光盘,DVD等设备都暂时挂载于此.常见的文件名有：/media/floppy、/media/cdrom等
/mnt如果你想要暂时挂载某些额外的设备,一般建议你可以放置到这个目录中.在早些时候,这个目录的用途与/media相同.只是有了/media之后,这个目录就暂时用来挂载
/opt这个是给第三方辅助软件放置的目录,什么是第三方辅助软件？举例来说,KDE这个桌面管理系统是一个独立的软件,不过它可以安装到Linux系统中,因此KDE的软件就建议放置到此目录下.另外,如果你想要自行安装额外的软件(非原本的发行版提供),那么也能够将你的软件安装到这里来.不过,以前的Linux系统中,我们还是习惯放置在/usr/local目录下
/run早期的FHS规定系统启动后所产生的各项信息应该要放置到/var/run目录下,新版的FHS则规范到/run下面,由于/run可以使用内存来模拟,因此性能上会好很多
/sbin Linux有非常多命令是用来设置系统环境的,这些命令只有root才能够用来设置系统,其他用户最多只能用来查询而已.放在/sbin下面的为启动过程中所需要的,里面包括了启动、修复、还原系统所需要的命令.至于某些服务器软件程序,一般则放置到/usr/sbin/当中.至于本机自行安装的软件所产生的系统执行文件 (system binary),则放置到/usr/local/sbin/当中了.常见的命令包括：fdisk、fsck、ifconfig、mkfs等
/srv可以视为service的缩写,是一些网络服务启动之后,这些服务所需要使用的数据目录,常见的服务例如WWW、FTP等.举例来说,WWW服务器需要的网页数据就可以放置在/srv/www/里面.不过,系统的服务数据如果尚未要提供给因特网任何人浏览的话,默认还是建议放置到/var/lib下面即可
/tmp这是让一般用户或是正在执行的程序暂时放置文件的地方.这个目录是任何人都能够存取的,所以你需要定期地清理一下.当然,重要数据不可放置在此目录.因为FHS甚至建议在启动时,应该要将/tmp下的数据都删除

/usr第二层FHS设置.是Unix Software Resource(Unix操作系统软件资源)的缩写.里面放的内容属于可分享不可变动(shareable, static),FHS建议所有软件开发者,把他们的资料合理的分别放到这个目录下的次目录,而不是自行建立软件自己的独立目录.系统自带软件都放在/usr底下.这个目录占用磁盘空间较大.
/usr二级目录: 
FHS要求必须要存在的目录
/usr/bin 所有一般用户使用的命令都放这里,CentOS7将/bin也链接到这里,/usr/bin等于/bin,FHS要求此目录不能有子目录
/usr/lib /lib链接到这个目录,与/lib功能相同
/usr/local 系统管理员在本机安装的软件放在此目录,安装的新软件可与旧软件分开,该目录同时具有bin,etc,include,lib的次目录
/usr/sbin 非系统正常运行的指令,常见网络服务器软件服务指令,与/sbin相同,/sbin链接到该目录
/usr/share 主要存放只读架构的资料文件,包括共享文件.放置的文件几乎是不分硬件架构均可读取的文件,都是纯文本文件,常见/usr/share/man线上说明文件,/usr/share/doc软件杂项的文件说明,/usr/share/zoneinfo与时区有关的文件
FHS建议可以存在的目录
/usr/games 与游戏相关的文件
/usr/include C/C++等编程语言的header与include放置区,以tarball方式(.tar.gz的方式安装软件)安装某些文件,使用里面很多include文档.
/usr/libexec 不被一般使用者使用的可执行文件或脚本,如视图界面的操作指令
/usr/lib<qual> 与/lib<qual>功能相同,链接到此目录
/usr/src src是source的意思,源代码放在这里,内核源码建议放在/usr/src/linux下

/var第二层FHS设置,主要为放置变动性的数据.是variable的缩写.系统运行时才会渐渐占用磁盘空间.主要针对动态变动的文件,包括cache,logfile以及某些软件运行所产生的文件,lockfile,runfile,如MySQL资料库文件等
FHS要求必须要存在的目录
/var/cache 程序运行过程中会产生一些缓存文件
/var/lib 程序执行过程中,需要使用到的文件放置的目录,此目录下各自软件有各自目录,如MySQL的库文件放到/var/lib/mysql,rpm的库文件放到/var/lib/rpm中
/var/lock 某些设备或文件一次只能被一个软件使用,如果同时有两个软件使用这个文件会发生冲突,因此就会把装置上锁,确保只会给单一软件使用.如烧录光盘,第一个人在烧录时就会上锁,第二个人只能等待第一个人完成后才能继续使用.这个目录被移到/run/lock中.
/var/log 非常重要,登陆文件放置的目录,如/var/log/messages,/var/log/wtmp登录者信息等.
/var/mail 个人电子邮箱的目录,有时会链接到/var/spool/mail.
/var/run 某些程序或者服务启动之后,会将PID放到这个目录下,与/run相同,会链接过来
/var/spool

FHS建议可以存在的目录
/home这是系统默认的用户家目录 (home directory).在你新增一个一般用户账号时,默认的用户家目录都会规范到这里来,比较重要的是家目录有两种代号：~代表当前用户的家目录,~username代表username的家目录.
/lib<qual>用来存放与/lib不同的格式的二进制函数库,例如支持64位的/lib64函数库等
/root系统管理员 (root)的家目录,之所以放在这里,是因为如果进入单人维护模式而仅挂载根目录时,该目录就能够拥有root的家目录,所以我们会希望root的家目录与根目录放置在同一个分区中

FHS以外的Linux目录
/lost+found这个目录是使用标准的ext2、ext3、ext4文件系统格式才会产生的一个目录,目的在于当文件系统发生错误时,将一些遗失的片段放置到这个目录下,不过如果使用的是xfs文件系统的话,就不会存在这个目录
/proc这个目录本身是一个虚拟文件系统 (virtual filesystem),它放置的数据都是在内存当中,例如系统内核、进程信息 (process)、外接设备的状态及网络状态等.因为这个目录下的数据都是在内存当中,所以本身不占任何硬盘空间.比较重要的文件例如：/proc/cpuinfo、/proc/dma、/proc/interrupts、/proc/ioports、/proc/net/*等
/sys这个目录其实跟/proc非常类似,也是一个虚拟的文件系统,主要也是记录内核与系统硬件信息相关的内容.包括目前已加载的内核模块与内核检测到的硬件设备信息等,这个目录同样不占硬盘容量

Linux设计初期,如果发生问题进入救援模式,通常只挂载根目录,/etc,/bin,/dev,/lib,/sbin这五个目录要求放在一起.如今/usr目录很多内容都移出去了,文件越来越精简,/usr被建议即使挂载成为只读,系统也能正常运行,所以/usr也能同时挂载了.所以/sbin,/bin,/lib都移动到/usr下了.

CentOS7的优化配置,FHS以外的配置就可以随开发者自行制定,网络配置资料放在/etc/sysconfig/network-script目录下,但是SuSE将网络配置放在/etc/sysconfig/network目录下.许多放在根目录下的目录链接到了其他目录下,/bin->/usr/bin, /sbin->/usr/sbin, /lib->/usr/lib, /lib64->/usr/lib64, /var/lock->/run/lock, /var/run->/run

除了FHS外,还有Linux Standard Base(LSB)的标准可以遵循,除了用ls -l / 检查根目录来判断是否遵循FHS,还能用uname检查系统内核版本,











# PAM模块 13.5

PAM带有认证机制, /usr/include, /usr/lib, /usr/lib64






系统账号使用/sbin/nologin无法登录shell, 但是可以使用系统资源. 当他们不能登录主机时,/sbin/nologin有提示信息, 覆盖默认内容

```bash
su - mail # 输出 This account is currently not available.
vim /etc/nologin.txt # 覆盖原来的输出信息
su - mail # 显示/etc/nologin.txt里的信息

```

/etc/login.defs文件默认密码长度是5个字符串长度, 这个值已经被PAM模块取代
嵌入式模块(Pluggable Authentication Modules, PAM), 避免不同的软件使用不同的密码认证机制. PAM是一套应用程序接口API(Application Programming Interface), 用户调用后PAM就能返回结果, passwd命令使用pam_cracklib.so模块能检测密码强度










last 列出所有登录者信息, 



# 13.6

查看当前登录主机的使用者, 还可以与使用者对话

```bash
# w 目前系统上的登录者
# 第一行显示目前的时间, 开机时间, 多少使用者和平均负载
# 第二行只是各项说明
# 第三行之后, 每行一个使用者, dmtsai登录并取得终端名tty2
w

# who 目前系统上的登录者
who # 输出名字 终端号 时间

# lastlog 每个账号的最近登入时间, lastlog读取/var/log/lastlog文件
lastlog

# write 发送信息给用户, Ctrl-D结束对话
# write 使用者账号 使用者所在的终端界面
write vbird1 pts/2 # 发送信息给vbird1

# mesg 拒绝接受信息
mesg # 查看当前状态
mesg n/y # 不想接受任何信息, 恢复接受任何信息

# wall 对系统上所有使用者传送信息
wall "I will shutdown my linux server..."



```

mailbox 收发邮件, 一般都放在/var/spool/mail里面, 一个账号一个mailbox

```bash
# mail 邮件
mail -s "Tiele" username@localhost
mail -s "nice to meet you" vbird1 # 寄给本地使用者, 正文写在下面, 用.结尾
mail -s "bashrc file content" dmtsai < ~/.bashrc # 发送家目录下的文件
ls -al ~ | mail -s "myfile" root # 发送给root输出内容

mail # 收信
& ? # 查看指令
# h 列出信件标题, h 40 查阅40封左右信件
# d 删除后接信件号码
# s 将信件存储成文件 s 5 ~/mail.file
# x 类似于exit, 无操作关闭
# q 执行你刚才的动作


```































