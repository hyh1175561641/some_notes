


# 文本编辑器

vim,emacs 另外记录


```bash

# nano
# nano版本 打开的文件 下边是操作界面
# Ctrl+G 线上帮助
# Ctrl+R 把其他文件内容粘贴进来
# Ctrl+O 保存修改
# Ctrl+W 查找字符串
# Ctrl+C 显示当前光标所在位置
# Ctrl+_ 光标快速移动到该行
# Ctrl+X 关闭软件
# Alt+Y 矫正语法功能
# Alt+M 鼠标移动光标功能

nano text.txt # 打开文件




```

# 查看文件内容

```bash

# cat concatenate的缩写,查看文件内容
# -A 相当于-vET的组合选项,
# -b 列出行号,空白行不标行号
# -E 显示结尾的$符号
# -n 列出行号,空白行也有行号,与-b选项有区别
# -T 将Tab以^I显示出来
# -v 列出一些看不出来的特殊字符
cat /etc/issue # 查看/etc/issue的内容
cat -A /etc/man_db.conf # 列出文件内容,显示tab特殊符号结尾符号$s

# tac 反序查看文件内容
tav /etc/issue # 反向查看文件内容

# nl 显示时输出行号
# -b 显示行号 -b a 空行也进行显示 -b t 空行不列出行号
# -n 行号显示方法 -n ln行号左边显示, -n rn行号右边显示不加0, -n rz行号右边显示加0
# -w 行号符号的占用的字符数
nl -b a /etc/issue # 空行也显示行号
nl -b a -n rz /etc/issue # 行号向右对齐,前面用0补齐空白符
nl -b a -n rz -w 3 /etc/issue # 行号只有三位数

# more 一页一页显示文件内容,最底下一行显示进度和--more--
# space 下一页
# Enter 下一行
# /字符串 向下搜索关键字
# :f 显示文件名和目前显示的行数
# q 离开more,不显示该文件内容
# b或ctrl-b 向上翻页,仅对文件有用,对管线无效
more /etc/man_db.conf # 查看文件内容
/MANPATH # 向下搜索字符串

# less 一行一行查看文件内容,可以往前翻页,man命令也是使用less来操作的
# space/PageDown 下一页
# PageUp 上一页
# / 向下搜索字符串
# ? 向上搜索字符串
# n 重复前一个搜索 与/?有关
# N 重复前一个搜索 与/?有关
# g 前往文件第一行
# G 前往文件最后一行
# q 离开less
less /etc/man_db.conf # 查看文件内容

# head 显示头几行
# -n 后面接数字,表示显示几行的意思
head /etc/man_db.conf # 默认显示头10行
head -n 20 /etc/man_db.conf # 显示头20行
head -n -100 /etc/man_db.conf # 负号意味着前100行不显示,从101行显示内容

# tail 显示末尾几行
# -n 后面接数字,代表显示几行的意思
# -f 表示持续检测文件的末尾几行,直到按下ctrl+c才结束
tail /etc/man_db.conf # 显示后10行
tail -n 20 /etc/man_db.conf # 显示后20行
tail -n +100 /etc/man_db.conf # 不知道有几行,只想列出100行以后的内容
tail -f /var/log/messages # 持续检测文件内容更新
head -n 20 /etc/man_db.conf | tail -n 10 # 取10-20行内容
cat -n /etc/man_db.conf | head -n 20 | tail -n 10 # 显示行号

# od 以二进制方式读取文件内容
# -t 接文件类型参数 a默认字符输出,cASCII字符输出,d[size]十进制decimal输出每个数占size bytes,f[size]浮点数floating输出每个数占size bytes,o[size]八进制octal输出每个数占size bytes,x[size]十六进制hexadecimal输出每个数占size bytes,
od -t c /usr/bin/passwd # 以ASCII输出文件
od -t oCc /etc/issue # 将这个文件内容以8进制和ASCII对照表列出
echo password | od -t oCc # ASCII与字符对照表


od -t x8 /bin/ls | less # 以十六进制8位输出




```


# 正则表达式
正则表达式(Regular Expression,RE),通过一些特殊字符排列,用来搜索替换删除一列或多列字符串,他是以行为单位来进行字符串的处理行为,只要程序支持正则表示法,那么该程序就可以用正则表达式处理字符串,如vi,grep,awk,sed等工具.但是cp,ls等指令不支持正则表达式,所以只能用bash自带的通配符表示.
正则表达式应用于系统管理员查找系统日志,过滤垃圾邮箱,这些规则需要由系统管理员加入比较规则.
延伸正则表达式要比基础正则表达式更加多功能,可以处理群组字符串处理.
正则表达式和通配符完全不一样,通配符(wildcard)表示bash操作界面的一个功能,正则表达式是一种字符串处理方式,两者有区别.

字符语系对排序的结果有影响,若提取大写字母时[A-Z],LANG=C可以捕捉到大写字母,LANG=zh_TW可以捕捉到除了小写a以外的所有字母,以下练习我们都使用LANG=C这个语系,特殊符号不受语系的影响
LANG=C:012-ABC-Zabc-z,
LANG=zh_TW: 012-aAbBcC-zZ,
export LC_ALL=en_US.utf8 修改语系,或者修改/etc/locale.conf

特殊符号
[:alnum:] 表示数字和大小写字母,0-9,A-Z,a-z
[:alpha:] 表示任何英文大小写字母,A-Z,a-z
[:blank:] 表示空格键与tab键
[:cntrl:] 表示控制字符,包括CR,LF,Tab,Del等
[:digit:] 表示数字,0-9
[:graph:] 除了空白字符(空格键与tab键)以外的其他字符
[:lower:] 表示小写字母,a-z
[:print:] 表示任何可以打印出来的字符
[:punct:] 表示标点符号(punctuation symbol),"'?!;:#$等符号
[:upper:] 表示大写字母,A-Z
[:space:] 任何空白字符,空格键,tab,CR等
[:xdigit:] 表示16进制数字类型,0-9,A-F,a-f

```bash
# 字符符号
^ 选择行首开头符号
$ 选择行尾结束的符号
. 表示一个而且一定只有一个任意字符
\ shell转义字符,\',\n
* 表示前一个字符重复零个到无穷多个,直到遇到下一个RE字符
[list] 字符集合,选择其中一个匹配的字符
[n1-n2] 字符范围,选择其中一个匹配的字符
[^list] 不要的字符范围,选择其中一个字符不进行匹配,^在中括号内部表示反向选择
\{n,m\} 前一个字符重复n-m次,go{2,10}gle,字母o重复2-10次

# 拓展符号,为了简化操作
+ 一个或一个以上
? 零个或一个
| 或,表示两者之一,
() 表示字符串整体,如(abc|def|xyz)表示abc,def,xyz...
()+ 表示字符串,如(xyz)+表示xyz,xyzxyz,xyzxyzxyz...

```




# wc pr

```bash
# wc 单词数,行数,字符数,字节总数
wc test.txt # 输出内容统计信息

# pr 打印纯文字格式的文件
pr /etc/man_db.conf # 除内容之外,文件时间,文件名,页码也会显示

```

# print printf

```bash
# print




# printf 按照格式打印文件中的单词,空白符分割
# \a 警告
# \b 倒退键
# \f 清楚屏幕
# \n 新的一行
# \r Enter键
# \t 水平Tab键
# \v 垂直Tab键
# \xNN NN为两位数字,可以转换数字为字符
# %ns n是数字,字符串长度是n
# %ni n是数字,多少位整数
# %N.nf 浮点数,小数点前有N位数字,小数点后有n位数字
printf '%s\t %s\t %s\t %s\t %s\t \n' $(cat printf.txt) # 格式化输出文件中的单词
printf '%10s %5i %5i %5i %5i %8.2f \n' $(cat printf.txt|grep -v Name) # 格式化输出数据
printf '\x45\n' # 输出字符E的ASCII码值

```


# grep sed awk

```bash
# grep 进行字符串比较,然后将符合的那一行字符串列出来
# -a 将二进制文件以文本文件搜索
# -c 计算查找到的总数
# -n 显示行号
# -v 反向选择,显示没有搜索到的行
# -i 忽略大小写
# -A after后面可加数字,除了当前行外,后面的n行也要列举出来
# -B befer后面可加数字,除了当前行外,前面的n行也要列举出来
# -E 支持拓展正则表达式,或者直接输入egrep
# --color=auto 高亮显示搜索到的字符
grep 'mail' /lib/systemd/system/* #查找/lib/systemd/system/*文件夹下所有文件内容有关mail的整行内容
dmesg | grep 'qxl' # 列出内核信息,包括硬件检测的流程,qxl虚拟卡信息
dmesg | grep -n --color=auto 'qxl' # 显示行号和高亮
dmesg | grep -n -A3 -B2 --color=auto 'qxl' # 前三行后两行
# 练习
grep -n 'the' reg.txt # 显示行号,显示带有the的行内容
grep -vn 'the' reg.txt # 显示行号,反向选择不带the的行内容
grep -in 'the' reg.txt # 显示行号忽略大小写,选择不带the的内容
grep -n 't[ae]st' reg.txt # 选择符合test和tast的内容
grep -n '[^g]oo' reg.txt # 选择开头不是g的oo内容
grep -n '[^a-z]oo' reg.txt # 选择开头不是小写的oo内容
grep -n '[0-9]' reg.txt # 选择带有数字的内容
# 语系影响
grep -n '[^[:lower:]]oo' reg.txt # 开头不是小写的那一行
grep -n '[[:digit:]]' reg.txt # 带有数字的那一行
# 行首行尾
grep -n '^the' reg.txt # 行首带有the的那一行
grep -n '^[a-z]' reg.txt # 行首小写的那一行
grep -n '^[[:lower:]]' reg.txt # 同上
grep -n '^[^a-zA-Z]' reg.txt # 开头非字母的内容
grep -n '^[^[:alpha:]]' reg.txt # 同上
grep -n '\.$' reg.txt # 以.结尾的内容
cat -An reg.txt # 查看部分内容不是以$结尾
grep -n '^$' reg.txt # 找到空白行
cat -n /etc/rsyslog.conf # 查看文件的内容,里面有注释和空行
grep -v '^$' /etc/rsyslog.conf | grep -v '^#' # 不要空白行,不要注释行
# 任意字符,重复字符
grep -n 'g..d' reg.txt # 选择g和d之间有两个字母,good,glad
grep -n 'ooo*' reg.txt # 至少两个o或者更多o
grep -n 'g*g' reg.txt # 匹配g,gg,ggg,gggg
grep -n 'g.*g' reg.txt # g与g之间有无限任意字符
grep -n '[0-9][0-9]*' reg.txt # 带有1个及以上任意长度数字的内容
# 连续字符串
grep -n 'o\{2\}' reg.txt # 匹配oo
grep -n 'o\{2,5\}' reg.txt # 匹配2-5个o
grep -n 'o\{2,\}' reg.txt # 匹配2个及以上o

# egrep 支持拓展正则方法 
egrep -n 'gd|good' reg.txt
egrep -v '^S|^#' reg.txt # 消除文件中的注释和空行

```

```bash
# sed 选择特定行,并且能够替换,新增,删除
# -n 使用安静模式,仅显示sed处理的行
# -e 在指令列模式进行编辑操作
# -f 将动作写入到文件中,后接文件名
# -r 支持正则表达式的拓展部分
# -i 修改内容,而不是屏幕输出
# [n1[,n2]]function n1,n2一般表示动作的行数,后接动作
# a 新增内容,后面接字符串,在内容下的新的一行输出
# c 替换,后接替换的内容
# d 删除某一行,后面不接内容
# i 插入,后接字符串,在内容上面一行输出
# p 打印输出,一般会抵消-n的作用
# s 取代,一般可搭配正则表达式
nl /etc/passwd | sed '2,5d' # 显示行号,删除2-5行,'2d'删除第二行
nl /etc/passwd | sed '3,$d' # '3,$d'删除3到最后一行
nl /etc/passwd | sed '2a drink tea' # 在第二行后面加上内容,也就是第三行
nl /etc/passwd | sed '2i drink tea' # 在第二行前面加上内容
nl /etc/passwd | sed '2a Drink tea or ...\
> drink beer ?' # 使用转移符号添加多行
nl /etc/passwd | sed '2,5c No 2-5 number' # 将2-5行内容取代成字符串
nl /etc/passwd | sed -n '2,5p' # 仅输出2-5行的内容,类似于|head -n 20| tail -n 10
# sed 's/正则表达式/新字符串/g'
/sbin/ifconfig lo0 | grep 'inet[^6]' # 选择inet那一行
/sbin/ifconfig lo0 | grep 'inet[^6]' | sed 's/^.*inet //g' # 开头部分删掉
/sbin/ifconfig lo0 | grep 'inet[^6]' | sed 's/^.*inet //g' | sed 's/ *netmask.*$//g' # 结尾部分删掉
cat /etc/man.conf| grep 'MAN' | sed 's/#.*$//g' | sed '/^s/d' # 查看MAN的行,删掉注释,删掉空行
sed -i 's/\.$/\!/g' reg.txt # 直接修改文件内容,.结尾的行换成!
sed -i '$a # This is a test' reg.txt # 表示最后一行,后面加一段内容

```

```bash
# awk 以行为单位处理,以单词为最小单位处理,必须用单引号扩起来,双引号不能套单引号
# awk读取到第一行,并将内容填到 $0 $1 $2 $3 $4...中,根据条件类型的限制,判断后续动作,做完所有的动作与条件类型,如果还有一行,则重复上述动作
# NF 每行拥有的总数
# NR 当前行为第几行
# FS 目前的分隔符,默认空格键
last -n 5 # 显示成功登陆到系统的用户信息
last -n 5 | awk '{print $1 "\t" $3}' # 显示用户名和IP地址
last -n 5 | awk '{print $1 "\t lines: " NR "\t columns: " NF}' # 用户名 第几行 变量总数
ls -al | awk '{print $1 "\t" $9}' # 显示第一个单词和文件单词

# 逻辑运算
# > < >= <= == != 
cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}' # :为分隔符,第三个变量UID小于10
cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}' # BEGIN和END有作用

# Name    1st     2nd     3th    #      Total
# VBird   23000   24000   25000  #   72000.00
# DMTsai  21000   20000   23000  #   64000.00
# Bird2   43000   42000   41000  #  126000.00
cat pay.txt | \ # 在末尾计算总量
> awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
> NR>=2{total = $2 + $3 + $4
> printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
cat pay.txt | \ # 支持if功能
> awk '{if(NR==1) printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total"}
> NR>=2{total = $2 + $3 + $4
> printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'

```


# 文本重定向



# 管道命令


```bash




```



# diff patch cmp

```bash
# diff 以行为单位进行比较
# from-file 原始文件名
# to-file 目标文件名
# -b 忽略一行中的多个空白符
# -B 忽略空白行
# i 忽略大小写
cat old.txt | sed -e '4d' -e '6c no six line' > new.txt # 创建新文件
diff old.txt new.txt # 比较两个文件差异
diff -Naur old.txt new.txt # 常用参数命令,制作补丁文件
diff -Naur old.txt new.txt > patch.patch # 补丁文件加后缀patch
# 4d3 原文件第四行删除,对准目标文件第三行
# 6c5 原文件第六行被取代,对准目标文件第五行
diff /etc/rc0.d /etc/rc5.d # 比较两个目录的差异,开机启动执行等级

# cmp 以字节为单位进行比较
# -l 将所有不同的点元位列出来
cmp old.txt new.txt # 比较两个文件的二进制不同

# patch
# -p 后接取消目录
# -R 还原,将新文件还原成旧文件
# patch -pN < patch_file # 更新
# patch -R -pN < patch_file # 还原
patch -p0 < patch.patch # -p0表示在同一个目录下

```






