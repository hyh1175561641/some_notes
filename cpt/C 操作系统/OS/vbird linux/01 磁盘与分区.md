






8.3 tar内容不全
8.4没整理
8.5没整理
8.6没整理







# 磁盘
硬盘 软盘 MO CD DVD 磁带机 U盘闪存 蓝光光驱 大型机器的区域网络储存设备SAN NAS
电脑硬盘分为 3.5英寸 2.5英寸
硬盘接口 SATA取代IDE SAS取代SCSI 外接接口USB eSATA等接口

硬盘的机械组成,数据通常是从外圈开始向内写
圆形盘片 记录数据的部分,有些硬盘有多个盘片
机械手臂 磁头用来读写数据
主轴马达 可以转动盘片
硬盘缓冲内存 可以将常用的数据高速缓存起来,以加速系统的读取性能,目前主流有64MB大小的内存
转速 台式机7200转 笔记本5400转
避免抖动 电脑运行时不要移动主机,电脑风扇异常不要拍打机箱


数据组成的最小单位
扇区 Sector 最小的物理存储单位, 512Bytes和4K两种流行的格式,每个扇区都有其号码
磁道 track 单面中连续组成的扇区
柱面 Cylinder 多面中组成扇区围成一个圆,过去磁盘分区的最小单位是柱面,现在是扇区
多个盘片的面加起来组成一个柱面

磁盘分区
MBR(Master Boot Record) 限制较多,第一扇区记录了主要开机区Master boot record, 共512bytes, MBR及分区表partition table,(MBR占有446Bytes,partition table占有64Bytes)
最多只能分为四个分区,每个分区能分成主要分区primary,延伸分区Extended,逻辑分区logical partition.分区最小单位是柱面.Extended最多只能有一个

GPT(GUID partition) 较新且限制较少,分区数量扩充较多,支持的磁盘容量超过2TB.
64bit记录功能的分区表,GPT分区详细信息见鸟哥2.2.2
不论在512Bytes还是4K的扇区中, 逻辑区块位址Logical Block Address LBA,默认为512Bytes
LBA0 第一个LBA区块 512Bytes大小 与MBR相兼容,但是又有独特的标识信息
LBA1 GTP表头信息 Primary GPT Header 记录了分区表本身的位置与大小,与备份用的GPT分区
LBA2-33 实际记录分区信息处,每个LBA可以记录4个分区记录,共128个分区记录,每个分区记录大小是128Bytes,开始和结束的扇区号码分别用64bits来记录,单分区最高达8ZB大小(百度上说18ZB的)
末尾的33个LBA用作备份


在Linux中,(a-p是16个选择)
/dev/sd[a-p] 实体磁盘的文件名,第一颗磁盘的文件名为/dev/sda
/dev/sda[1-128] 磁盘当中的分区的文件名,第一个分区文件名是/dev/sda1
/dev/vd[a-p] 虚拟磁盘的文件名,常用于虚拟机内,或者网际提供商申请的云端机器
/dev/md[0-128] 软件磁盘阵列
/dev/VGNAME/LVNAME 软件磁盘阵列等格式
/dev/fd[0-7] 软盘机
/dev/lp[0-2] 25针打印机
/dev/usb/lp[0-15] USB接口打印机
/dev/input/mouse[0-15] 鼠标(通用) /dev/psaux(PS/2界面) /dev/mouse(当前鼠标)
/dev/scd[0-1] CDROM/DVDROM(通用) /dev/sr[0-1]通用 /dev/cdrom当前CDROM
/dev/ht0 磁带机IDE界面 /dev/st0 SATA/SCSI界面 /dev/tape当前磁带
/dev/hd[a-d] IDE硬盘机 旧式系统



# 文件系统

文件系统种类
Linux最传统的文件系统是 EXT2fs(Linux second extended file system)
Windows98 FAT/FAT16
Windows2000 NTFS
CentOS XFS(SGI的)
其他文件系统 ExFAT VFAT
传统文件系统: ext2 minix MS-DOS FAT(用vfat模组) iso9660(光碟)
日志文件系统: ext3/4 ReiserFS(适用更小型文件) Windows'NTFS IBM'sJFS SGI'sXFS ZFS
网络文件系统: NFS SMBFS

LVM与软件磁盘阵列技术可以将一个分区格式化为多个文件系统,也能将多个分区合成一个文件系统(LVM,RAID),换种说法称呼为一个可被挂载的数据为一个文件系统而不是一个分区


索引式文件系统 indexed allocation,以树形结构存储文件属性和内容 比如 ext2
链表式文件系统 比如FAT,如果文件内容太分散会降低效率,碎片整理会解决这个问题

文件系统ext2/3/4族,含有Boot Sector,Block Group(Superblock,filesystem description, block bitmap, inode bitmap, inode table, data block), Block Group1, Block Group2.
较新的文件系统通常含有两部分,分区一旦格式化inode与block就不会变动.
Boot Sector:开机管理程序,不用去覆盖MBR,支持多重开机环境.
superblock 超级区块,记录整个文件系统的整体信息,包括inode/block的总量/剩余量,block与inode的单个大小.文件系统的挂载时间,最近写入时间,最近检查时间等,valid bit表示0未挂载1已挂载.superblock在后边有很多备份.
filesystem description: 描述每个blockgroup起始结束位置,以及每段superblock,bitmap,inodemap,datablock的位置.
blockbitmap,inodebitmap 区块对照表和inode对照表,标记空间是否已被使用.
inode table: 记录文件的属性,一个文件占用一个inode.inode记录了权限rwx,拥有者群组owner/group,文件大小,创建时间,读取时间,修改时间,定义文件的flag(SetUID),文件内容的指针,比如能记录12个直接号码,1个间接,1个双间接,1个三间接,文件总共16G大小(较小的情况).每个inode大小占用128bytes/256bytes,读取文件需要先分析inode的权限是否符合,然后才能读取内容.
data block: 记录文件的实际内容.若文件太大时,占用多个block.一个block支持的大小有1K,2K,4K.如果文件小于block,则剩余容量就浪费了.

目录文件: inode记录目录的属性,block记录目录的子文件名和inode位置.读取目录文件意味着可以查看子文件列表,写入目录意味着增删改子文件,执行目录意味着进入该目录.当我们读取/etc/passwd文件时,系统会从根目录一层一层地往下读取, / => /etc => /etc/passwd.
当文件系统使用一段时间后,block离散会太严重,这时把文件复制出去再格式化磁盘,再复制回来才能解决.
日志文件系统Journaling filesystem: 如果硬盘在读写时遭到断电或其他意外情况,数据写入到inode和block中,而bitmap却没有被更新.日志区块记录写入或修改文件的步骤,这样可以加速检查操作.
当操作系统修改一个文件时,是在内存当中进行的,其间间断地写入硬盘,或者手动执行sync命令强制文件写入硬盘
把文件系统对应到目录树上面,这个动作称为挂载,必须挂载后,才能使用该文件系统,挂载点一定是目录,而且该目录成为该文件系统的入口.
Linux VFS(Virtual Filesystem Switch): VFS来管理目录树下挂载的不同的文件系统
EXT文件系统家族的缺点,当磁盘容量变大时,格式化速度变慢,比如格式化70TB的磁盘整列需要时间等待,GB级别文件效率不如XFS快

```bash
man ext2 # ext2/3/4族工具集 fdisk 

# dumpe2fs 查看ext文件系统信息
# -b 列出保留为坏轨的部分,不常使用
# -h 列出superblock的资料,不展示block资料
# 第一部分是文件系统的各种信息,第二部分是每个block group的信息
dumpe2fs /dev/sda1 
Filesystem volume name: <none> # 文件系统名称
Inode count: 65536 # inode的总数
Block count: 262144 # block的总数
Block size 4096 # 单个block容量大小
Inode size 256 # inode容量大小
Journal size: 128M # 日志资料可供存储总量
Group 0: (Blocks 0-32767) # 第一个group的位置
Free blocks/inode: 37-183 # 剩余容量

# tune2fs 修改ext4的label和UUID
# -l 查看分区的superblock信息,类似于dumpe2fs -h
# -L 设置分区的label
# -U 设置分区的UUID
tune2fs -L newExt4Name /dev/sdb1 # 修改label
tune2fs -l /dev/sdb1 | grep name # 查看label


mke2fs
mke2fs.conf
tune2fs
debugfs
chattr




```

XFS系统 从CentOS7开始使用XFS文件系统
XFS格式化速度比EXT快,GB级别文件读写效率比EXT快.开发之初就是为了用于高容量高效率之用,功能基本覆盖EXT文件系统.
资料区data section: 多个allocation groups储存群组,包含整个文件系统superblock,剩余空间管理机制,inode分配与追踪,inode和block需要用才生成
活动登录区log section: 主要记录文件系统的变化,只有文件最终写入完成,这个步骤才会结束,XFS可以把这个分区指定到外部磁盘来操作,比如SSD磁盘,可以加快速度.
即使运作区realtime section: 当新文件创建时,找到extent区块,写入进去,然后等分配完毕,再写入到data section中的inode与block中去.


```bash
man xfs # xfs文件系统工具集
# xfs_info 查看xfs文件系统信息
xfs_info /dev/sda1 (或/或/home 也可以写成挂载点,根目录挂载点)

# xfs_admin 修改XFS文件系统的UUID与Label
# -l 查看分区的label
# -L 设置分区的label
# -u 查看分区的UUID
# -U 设置分区的UUID
xfs_admin -L newLabelName /dev/sdb1 # 设置新label
xfs_admin -l /dev/sdb1 # 查看新label名称
xfs_admin -U xxxx /dev/sdb1 # 查看UUID
xfs_admin -u /dev/sdb1 # 查看UUID
uuidgen # uuid生成器


chattr
xfsctl
xfsdump
xfsre-store



```




# 查看分区




```bash
# df 列出文件系统的整体磁盘使用量,主要读取的是superblock中的信息
# df [option] [设备名称|挂载点]
# -a 列出所有的文件系统,包括/proc等文件系统
# -h 以用户便捷的单位显示 比如 1K 234M 2G
# -H 以M=1000K取代M=1024K的进制位方式
# -k 以kb单位显示容量大小
# -m 以mb单位显示容量大小
# -i 以inode数量单位显示容量大小
# -T 显示文件系统类型
df
Filesystem 1K-blocks Used Available Use% Mounted on
分区名称 容量大小基础单位1K 已使用 剩余容量 使用率 挂载点
df -aT # 列出所有的分区并显示文件系统格式类型
df -ih # 列出各分区中的inode,inode剩余量比block多
df -h /etc # 自动分析挂载点所在的分区,然后列出分区内容


# du 列出目录下所有文件与目录的大小,主要是读取inode里的信息
# -a 列出所有的文件与目录的大小
# -h 以人类易读的单位显示
# -s 列出总量,不列出具体的量
# -S 不包括子目录下的文件总量,不进行容量加总计算
# -b 以byte单位显示容量大小
# -k 以kb单位显示容量大小
# -m 以mb单位显示容量大小
du # 列出所有目录并标注大小
du -a # 列出文件和目录并标注大小
du -sm /* # 检查根目录底下每个目录所占用的容量
du -sh /* # 列出跟目录下每个目录占用的总量
du -sSh ./* # 列出目录下每个目录占用的量,不包括子目录



# dd 
dd if=centos7.iso of=/dev/sdc # 烧录U盘启动盘



```


link链接
hard link: 硬链接,通过目录block链接到其他inode中,两个目录内容指针指向inode,当其中一个源指向被删除时,目标不会消失.硬链接不会增加磁盘空间,不能跨分区,不能链接目录.可以通过两个源指向改变其文件属性.
symbolic link: 符号链接,类似于Windows的快捷方式.当目标文件删除时,源链接会显示找不到某文件,

``` bash
# ln 新建链接
# -s 表示这是symbolic符号链接
# -f 如果链接已存在,那么覆盖原链接

ln /etc/crontab /root/crontab1 # 硬链接
ls -li /etc/crontab /root/crontab1 # inode相同

ln -s /etc/crontab /root/crontab2 # 符号链接
ls -li /etc/crontab /root/crontab2 # inode不同 /etc/crontab是12个byte大小,所以符号链接大小显示12

du -sb; df -i # 当前文件998, 根目录挂载点使用32493
cp -a /etc/passwd . # 复制一个文件
du -sb; df -i # 当前文件1893, 根目录挂载点使用32494
ln passwd passwd-hd # 硬链接
du -sb; df -i # 当前文件1910应该不变是1893才对,根目录挂载点使用32494
ls -ali passwd passwd-hd # inode相同,权限和用户之间的硬链接数为2
ln -s passwd passwd-so # 符号链接
ls -ali passwd passwd-so # inode不同,硬链接数是1
du -sb; df -i # 当前文件1933, 根目录挂载点使用32495
rm passwd # 删除源文件
cat passwd-hd passwd-so # 硬链接正常,符号链接失效

# 新建一个目录时,链接数为2,比如新建aaa目录,aaa本身和.目录都链接本目录,所以为2.还有一个..目录,父目录的链接数加一
ls -ld /tmp # 链接数为9
mkdir /tmp/aaa # 新建一个aaa目录
ls -ld /tmp /tmp/aaa # 链接数为10和2

```


```bash
# lsblk 列出系统上所有的磁盘,和df命令类似
# -d 仅列出磁盘,不列出分区
# -f 显示文件系统类型
# -i 用ascii字符代替制表符
# -m 输出权限信息
# -p 输出完整的设备文件名称
# -t 列出详细资料
lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
名称 主要代码:次要代码 是否可卸载 容量大小 类型 挂载点
lsblk -ip /dev/sda # 列出完整的设备文件名,以ascii显示


# blkid 列出磁盘的uuid和文件系统类型
# 磁盘的UUID是唯一识别码,当你拿着U盘在各个电脑上来回装载时,可以使用UUID来唯一确定你的U盘



# 各种其他方式查看分区信息的方式
cat /etc/filesystems # 系统指定的测试挂载系统类型的优先顺序
cat /proc/filesystems # Linux系统已挂载的文件系统类型
cat /proc/filesystems # 已载入到内存中支持的文件系统
ls -l /lib/modules/$(uname -r)/kernel/fs # Linux支持的文件系统类型
ls -al /dev/sd* # 用户和日期之间的那个值和lsblk的主次版本代表文件系统的识别码

# e2fsck 检查是否被挂载
# sync 强制系统文件写入操作系统,假设新文本在内存中不在硬盘

```

```bash
# mknod 透过Major Minor这两个代码来识别一个硬盘
# -b 设置为储存设备文件,比如磁盘,U盘
# -c 设置为输入设备文件,比如键盘鼠标
# -p 设置为一个FIFO文件
mknod 设备文件名 [b/c/p] [major] [Minor] # 格式
mknod /dev/sdb11 b 8 17 # 新建一个储存设备文件
ls -al /dev/sdb* # b开头表示储存设备文件,用户名组后面是主次代码
mknod /tmp/testpipe p # 新建一个FIFO文件
ll -al /tmp/testpipe # 查看信息
rm /dev/sdb11 /tmp/testpipe # 删除刚才创建的设备文件

```


# 分区工具

步骤: 找到磁盘=>找出分区表类型=>建立分区=>格式化=>检验分区=>挂载
fdisk是MBR软件, gdisk/parted才能识别GPT
```bash
# 对磁盘进行分区操作时,最好把硬盘卸载掉,对系统磁盘进行操作时,关机用其他系统开机进行操作
# fdisk MBR分区表 操作方法和gdisk类似

# gdisk GPT分区表
# d 删除一个分区
# i 分区详情
# l 列出已知的文件系统类型
# n 新建一个分区 +G自动计算容量
# m 列出gdisk菜单 同?
# o 创建空的GPT分区表
# p 打印硬盘信息
# q 退出
# t 改变分区类型
# w 写入信息表数据,一旦写入,所有决定立刻生效
gdisk /dev/sda # 不要加上数字,不能对分区进行操作

# 分区成功后,内核并没有更新分区
# partprobe 更新Linux内核的分区数据
cat /proc/partitions 
partprobe -s # 把新分区加入内核
lsblk # 查看分区信息
cat /proc/partitions # 核心的分区信息



# parted 分区工具
# 新增 mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始 结束
# 显示 print
# 删除 rm [partition]
parted /dev/sda print # 列出磁盘的信息
Model: ATA VBOX HARDDISK (scsi) # 磁盘的名称(厂商)
Disk /dev/sdb: 21.5GB # 磁盘容量
Sector size (logical/physical): 512B/512B # 磁盘的逻辑/物理扇区容量
Partition Table: gpt # gpt分区
Disk Flages: # 标志
Number Start End Size File system Name Flags # 分区详情
编号 起始位置 结束位置 大小 类型 文件系统 标志
man parted # 查看手册
parted /dev/vda help mkpart # 查询详细资料
parted /dev/vda unit mb print # 固定用mb单位显示开始结束位置
parted /dev/sda mklabel gpt # MBR变GPT
parted /dev/vda mkpart primary fat32 36.0GB 36.5GB # 建立一个512MB的分区


# mkfs 分区格式化
# -t 转化成mkfs.xxx命令
mkfs[tab][tab] # 查看可以格式化的类型
mkfs -t vfat /dev/sdb1 # 格式化为vfat格式

# mkfs.ext4 把分区格式化成ext4
# -b 设定block大小,1K 2K 4K 的容量大小
# -L 后面接上装置的名称
mkfs.ext4 /dev/sdb1 # 格式化为ext4格式
  Filesystem label= # 显示Label name
dumpe2fs -h /dev/sdb1 # 显示分区的头信息


# 类似于Windows的scandisk
# fsck 修复文件系统
# fsck.ext4 修复ext4族文件系统
# -p 默认同意任何动作,过程间需要输入y的时候
# -f 强制详细检查,在没有unclean标志情况下
# -D 针对文件系统目录进行最优配置
# -b 后接superblock,救援superblock用
dumpe2fs -h /dev/sdb1 | grep Blocks per group # 查看
fsck.ext4 -b 32768 /dev/sdb1 # 修复
fsck.ext4 /dev/sdb1 # 文件系统恢复正常,不会进入强制状态
fsck.ext4 -f /dev/sdb1 # 强制详细检查


# mkfs.xfs 把分区格式化成xfs
# -kmgtp 单位KB MB GB TB PB 不加参数为Bytes
# -s sector扇区
# -b 后接block容量, 512-64k
# -d 参数,后面接data section参数值
# -f 如果分区已经被格式化,需要强制格式化
# -i 与inode有关的参数,后面接参数值
# -L 后面接文件系统表头名LabelName
# -r 指定realtime section相关extent数值
mkfs.xfs /dev/sdb1 # 快速格式化
blkid /dev/sdb1 # 查看刚才格式化的分区
grep 'processor' /proc/cpuinfo # 查看cpu信息
mkfs.xfs -f -d agcount=2 /dev/sdb1 # 与cpu核心数相关的参数
# mkfs.xfs 磁盘阵列的方法
mkfs.xfs -f -d agcount=2,su=256k,sw=7 -r extsize=1792k /dev/sdb1 # 加速磁盘阵列格式化速度
mkfs.xfs -f -d agcount=2,sunit=512,swidth=3584 -r extsize=1792k /dev/sdb1 # 加速磁盘阵列格式化速度

# xfs_repair 检查分区是否有故障,只能操作未挂载的分区
# -f 设备是个文件
# -n 仅仅检查并不修改任何资料
# -d 危险参数,单人模式下进行根目录检查修复动作
xfs_repair /dev/sdb1 # 共有7个检查流程



```


resize2fs 变更系统档案大小
cfdisk
sfdisk
partprobe
kpartx
mke2fs
tune2fs
lvm
lvextend



# 挂载

同一个文件系统不能重复挂载在不同的挂载点上.同一个目录不能挂载多个文件系统.挂载点的目录,应该是空目录才对,如果不为空,挂载点原有的文件和目录会暂时隐藏.

```bash

# mount 挂载系统目录
# -a 把/etc/fstab未挂载的磁盘都挂载上来
# -l 显示当前已挂载的信息
# -t 指定文件系统类型.linux类型xfs,ext3,ext4.光碟类型reiserfs,vfat,iso9660.网络类型nfs,cifs,smbfs.大多系统都能自动识别类型
# -n 不写入挂载情况到/etc/mtab,默认写入,加-n参数不写入
# -o 加入参数,比如账号密码读写权限等
#  async,sync 是否使用同步写入sync,或非同步async
#  atime,noatime 是否写入文件的读取时间atime,为了提高效率可能使用noatime
#  ro,rw 挂载的文件系统是只读ro或者可读写rw
#  auto,noauto 允许此文件系统被mount -a自动挂载
#  dev,nodev 允许此文件系统,建立设备文件
#  suid,nosuid 允许此文件系统含有suid/sgid的权限功能
#  exec,noexec 允许此文件系统拥有可执行的binary文件
#  user,nouser 允许此文件系统让任何使用者执行mount,一般仅root用户可挂载
#  defaults 默认值为rw,suid,dev,exec,auto,nouser,async
#  remount 重新挂载,系统出错或重新更新参数时有用

mount -l # 显示所有已挂载的信息
mkdir -p /data/xfs # 新建一个挂载点
mount UUID="xxxx" /data/xfs # 把某个分区挂载上去
df /data/xfs # 查看挂载详情
mount /dev/sdb1 /data/ext4 # 把分区挂载上去
df /data/ext4 # 查看挂载详情
mount /dev/sr0 /data/cdrom; df /data/cdrom # 挂载CD/DVD,图形界面光碟默认挂载目录是/media
mount -o codepage=950;iocharset=utf8 UUID="xxxx" /data/usb # 挂载U盘,指定资料中的中文编码, df /data/usb

# 如果根目录已挂载不能卸载,想要改变参数或者是只读状态,除了重启电脑,如何重新挂载?单人维护模式常用
mount -o remount,rw,auto / # 重新挂载根目录
mount -n -o remount,rw / # 把只读的挂载变成可读写的挂载
# 某些系统不支持符号链接,可以通过挂载目录来实现链接,挂载目标并非挂载文件系统
mkdir /data/var # 创建挂载点
mount --bind /var /data/var # 把目录挂载上去
ls -lid /var /data/var # 完全一样
mount | grep var 

# umount 卸载文件系统
# -f 强制卸载
# -l 立刻卸载,比-f还强
# -n 不更新/etc/mtab情况下卸载
umonut [-fn] 设备文件名或挂载点
umount /dev/sdb1 # 卸载设备文件
umount /mnt/usb # 卸载挂载点
umount /data/var # 卸载绑定挂载点/var和/tmp/var解绑

# 开机自动挂载
# 根目录/必须挂载,而且是第一个挂载
# 其他挂载点必须挂载到已存在的目录
# 所有挂载点同一时间内只能挂载一次
# 所有分区同一时间内,只能挂载一次
# 如果进行卸载,先将工作目录移动到挂载点及其子目录之外

cat /etc/fstab # 文件系统挂载
# 设备名称/UUID 挂载点 文件系统 文件系统参数 dump fsck
# 文件系统参数见上面的mount -o
# dump 表示能否被dump备份指令作用,0表示不启用该功能
# fsck 检查磁盘是否完整,文件系统自己会检测,0表示不启用该功能
umount /dev/vda4 # 卸载挂载的设备
nano /etc/fstab # 写入指令到最后一行,写入的指令将会开机自动挂载
UUID="/dev/vda4的UUID" /data/xfs xfs defaults 0 0 # 添加的设备和挂载点
mount -a # 检测写入的指令是否生效,格式是否正确
df /data/xfs # 查看状态

cat /etc/mtab # 自动挂载挂载
cat /proc/mounts # 已经挂载的信息


```


```bash

# ISO文件挂载使用
# ISO文件这样就能随意被修改,同时回提供一个md5给用户,来测试内容是否被修改
mount -o loop /tmp/centos.iso /data/centos # 把iso文件挂载到指定目录,默认是只读
ls -al /data/centos # 查看挂载情况
umount /data/centos # 卸载

# 建立一个超大文件, 制作loop文件, 格式化后挂载起来
dd if=/dev/zero of=/srv/loopdev bs=1M count=512 # 输入文件一直输入0, 输出文件写入到/srv/loopdev中, 每个block大小就像文件系统那样的block, count是总体容量 512*1M=512M
ll -h /srv/loopdev # 查看
mkfs.xfs -f /srv/loopdev # 文件格式化
blkid /srv/loopdev # 文件类型是xfs
mount -o loop UUID="xxx" /mnt # 加 -o loop参数挂载
df /mnt

nano /etc/fstab # 写入内容, 开机自动挂载
/srv/loopdev /data/file xfs defaults,loop 0 0
umount /mnt
mkdir /data/file
mount -a
df /data/file


```



# Swap

当系统的物理内存不够用的时候,把硬盘中的一部分空间释放出来,用来替代内存使用.一般来讲,swap分区容量应大于物理内存大小,建议是内存的两倍,但不超过2GB.

```bash
gdisk /dev/sda # 第一步新建swap空间
n +512M 8200 # 建立一个512M的新分区
p # 查看新分区信息
w # 保存更改
partprobe # 把新分区加入内核
lsblk # 查看新分区信息
mkswap /dev/vda6 # 第二步格式化分区为swap格式
blkid /dev/vda6 # 查看信息
free # 观察内存信息
swapon /dev/vda6 # 第三步开启swap分区
swapon -s # 第四步观察swap分区
nano /etc/fstab # 写入系统设定档


# loop文件来代替swap分割槽
dd if=/dev/zero of=/tmp/swap bs=1M count=128
ll -h /tmp/swap # 128M的新文件
mkswap /tmp/swap # 格式化
swapon /tmp/swap
swapon -s # 开启了swap文件

# 设置开机自动启动
nano /etc/fstab
/tmp/swap swap swap defaults 0 0
swapoff /tmp/swap /dev/vad6 # 关掉swap file
swapon -s
swapon -a






```

# 压缩和归档

计算机上比较大型的文件通过文件压缩之后,可以降低磁盘使用量,从而达到降低文件容量的效果.有的压缩程序还可以限制容量,把一个大型文件划分成数个小型文件,方便携带.
若要使用这些被压缩过的文件数据,必须将它解压缩成未压缩之前的模样.压缩后与压缩文件所占用的磁盘空间大小,就可以被称为是压缩比,参考链接：RFC 1952文件 GZIP文件格式规格4.3版本 https://www.ietf.org/rfc/rfc1952.txt.
压缩后的文件容量会变小,可以容纳更多数据.在网络传输中,会降低数据量,提高带宽利用率.其中纯文本文件的多余空间最多.

在linux环境中,压缩文件的扩展名大多是：
```bash
# 压缩命令拓展名是 gzip,bzip2,xz,tar
*.Z        compress程序压缩的文件
*.zip      zip程序压缩的文件
*.gz       gzip程序压缩的文件
*.bz2      bzip2程序压缩的文件
*.xz       xz程序压缩的文件
*.tar      tar程序打包文件,没有压缩过
*.tar.gz   tar程序打包文件,并且经过gzip的压缩
*.tar.bz2  tar程序打包文件,并且经过bzip的压缩
*.tar.xz   tar程序打包文件,并且经过xz的压缩

```
通过time [gzip|bzip2|xz] -c services > services.[gz|bz2|xz]命令得到结果,时间依次是0.019s,0.042s,0.261s,gzip时间最短,xz效果最好
压缩命令,各种格式对应各种命令,不能互通.
Linux上常见的压缩命令就是gzip、bzip和最新的xz,和已经不流行的compress.为了支持Windows常见的zip,Linux也有了zip命令.不过,这些命令通常仅能针对一个文件来压缩和解压缩.
tar命令可以将很多文件打包成一个文件甚至目录.单纯的tar仅能提供打包的功能,并没有提供压缩的功能.但是强大的tar命令与压缩功能结合起来,提供给用户更方便的功能


```bash
# gzip命令族 gzip zcat zmore zless zgrep
# gzip压缩的.gz文件可以被Windows的WinRAR和7zip软件解压缩,gzip和compress的关系见鸟哥8.2.1
# -c 把压缩后的数据输出到屏幕上（一堆乱码）
# -d 解压缩,等同于gunzip,将压缩文件删除,生成源文件
# -k 保留源文件
# -t 检验一个压缩文件的一致性
# -v 显示压缩比,（源文件-压缩文件）/源文件
# -1~9 压缩比,最好的是9,最快的是1,默认是6
# 由于压缩命令只能用于单一的文件,所以zcat zmore zgrep能查看文件内容
gzip file.c # 压缩文件并删除源文件
gzip -c file.c > file.c.gz # 压缩源文件并保留源文件
gzip -9 -c source > source.gz # 用最好的压缩比,并保留源文件,新数据定向到gz文件
gzip -d file.c.gz # 解压缩并删除源压缩包
gzip -dc file.c.gz > file.c # 解压源文件并保留源文件
zcat file.c.gz # 查看压缩文件内容
zgrep -n 'http' file.c.gz # 搜索符合条件的结果


# bzip2命令族 bzip2 bzcat bzmore bzless bzgrep
# bzip2用法几乎和gzip一样,但是压缩比要比gzip更好
# -c 把压缩后的数据显示在屏幕上（一堆乱码）
# -d 解压缩,等同于bunzip2
# -k 保留原始文件
# -v 显示压缩比
# -z 压缩的参数,这是默认值,可以不加
# -1~9 压缩等级 最好是9,最快是1,默认是6
bzip2 file.c
bzip2 -9 -c source > source.bz2

# xz命令 xzcat xzmore xzless xzgrep
# xz软件要比gzip耗费10倍有余的时间
# -c 把压缩后的数据显示在屏幕上（一堆乱码）
# -d 解压.xz文件
# -l 查看.xz文件信息
# -k 保留源文件
# -t 测试压缩文件的完整性,查看有没有错误
# -v 显示压缩比
# -1~9 压缩等级,最好是9,最快是1,默认是6
xz file.c # 压缩文件
xz -k file.c # 保留源文件并建立压缩文件
xz -d file.c.xz # 解压缩


```

https://www.gnu.org/software/tar/manual/
```bash

# tar命令
# 可以将多个文件或目录包成一个大文件,是一种打包命令,同时还能通过gzip、bzip2、xz的支持,将文件同时进行压缩.tar的使用非常广泛.鸟哥8.3.3后面讲如何备份/etc文件夹,解压缩单一的文件
tar [-zjJ] [cv] [-f 待创建的新文件名] filename... #打包与压缩
tar [-zjJ] [tv] [-f 既有的tar文件名] #察看文件名
tar [-zjJ] [xv] [-f 既有的tar文件名] [-C 目录] #解压

# -z 通过gzip (解)压缩 文件名最好是*.tar.gz
# -j 通过bzip2 (解)压缩 文件名最好是*.tar.bz2
# -J 通过xz (解)压缩 文件名最好是*.tar.xz
# zjJ不能出现在同一串指令中
# -c 创建新打包文件
# -t 查看文件名
# -x 解压缩 -C指定一个目录
# ctx不能出现在同一串指令中
# -f filename f参数后面时刻跟着一个待处理的文件名
# -v 将正在处理的文件名打印到屏幕上
# -C 后接目录, 在特定的目录解压缩
# -p小写 备份原本的权限与属性,备份重要的配置文件
# -P大写 备份绝对路径,如/etc解压后直接放到了/etc目录下
# --exclude=FILE 在压缩过程中, 不要将FILE打包
tar -zxv -f file.tar.gz # 解压缩
tar -ztv -f file.tar.gz | grep 'shadow' # 查看压缩包
tar -zxv -f file.tar.gz -C etc/shadow # 解压缩指定目录



tar内容不全, 日后再补充








```


# 文件备份















# 光盘等写入工具


从FTP网站下载的Linux ISO文件, 都要继续烧录成实际的光碟, 才能进一步使用, 用来安装和更新Linux

```bash
# mkisofs 操作光盘映像ISO文件
# -o 后接输出ISO文件名称
# -J 产生相容于Windows的文件名结构, 可增加文件名长度到64个unicode字节
# -r 通过Rock Ridge产生支持Unix的文件数据, 可记录较多的信息,如UID/GID
# -v 显示建立ISO的过程
# -V vol 建立Volume, 有点像文件管理器的CD title的东西
# m file -m为排除文件exclude, 后面的文件不备份到映像文件中, 也可使用*
# -graft-point graft是转嫁或移植的意思, 可指定目录内容部分






# isoinfo 可开机光盘映像


# cdrecord 光碟烧录工具




```





# 系统配额
quota

















