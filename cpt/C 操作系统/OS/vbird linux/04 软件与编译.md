


















# 开源软件

Windows平台安装软件只需要一直点下一步,但是开源软件可以修改源代码,定制你想要的功能,修复软件原有的漏洞.

源代码文件:一般是文本文件,经过编译后得到可执行文件.
编译器:将源代码编译成二进制程序后,得到机器识别的二进制文件.
可执行文件:Linux系统上面,二进制文件binary program,具有X执行权限,如/usr/bin/passwd,/bin/touch.
库函数:程序运行期间会调用外部函数库,并把返回值传给程序. 大多数放在/usr/include,/usr/lib,/usr/lib64中
make工具:编译大型软件需要使用make,在目录中寻找Makefile文件并进行编译.通常在此之前有一个configure或config文件来监测系统环境,用来生成Makefile文件.
检测环境工具:是否有适合的编译器可以编译源代码,是否已经存在所需要的库函数或其他依赖,操作系统或Linux内核是否适合本软件,内核的头文件是否存在.
不同的Linux发行版和函数库有所区别,生成的可执行文件有所不同,所以不同平台需要重复编译源代码.

```bash
file /bin/bash # 查看文件是否为可执行文件
file /etc/init.d/network # bash shell文件,ASCII文本文件

```










# gcc编译源文件

```c
//vim hello.c
#include <stdio.h>
int main(void){
    printf("Hello World\n");
}

/* 简单编译
gcc hello.c && ls hello.c a.out && ./a.out
*/
/* 生成目标文件并指定名字
gcc -c hello.c && ll hello* && gcc -o hello hello.o && ./hello
*/

```

```c
// 主程序,副程序的链接编译
// 当源文件含有多个文件,无法直接编译成二进制文件,之前要先生成目标文件
// 源文件修改后,仅需更新新修改的文件,其他文件可以不进行编译
// vim thanks.c
#include <stdio.h>
int main(void){
    printf("Hello World\n");
    thanks_2(); # 调用副程序
}
// vim thanks_2.c
#include <stdio.h>
void thanks_2(void){
    printf("Thank you!\n");
}

// gcc -c thanks.c thanks_2.c && ll thanks* # 编译目标文件
// gcc -o thanks thanks.o thanks_2.o # 链接生成可执行文件
// ./thanks # Hello World Thank you!

// gcc -O -c thanks.c thanks_2.c # 生成性能最好的程序
// gcc -Wall -c thanks.c thanks_2.c # 输出详细信息和警告信息

```

```c
// 调用第三方库函数
// vim sin.c
#include <stdio.h>
#include <math.h>
int main(void){
    float value;
    value = sin ( 3.14 / 2 );
    printf("%f\n",value);
}

// 旧版的gcc需要加上参数说明,表示调用了libm.so库函数,去/lib /lib64这两个目录搜索(不加也可以,默认就是找这两个目录)
// -l 加入某个函数库library
// m 表示libm.so这个函数库,libxxx.so(.a)可以省略
// -L 表示自动搜索/lib /lib64这两个目录
// gcc sin.c -lm -L/lib -L/lib64 # 重点在 -lm 调用libm.so函数库

// 搜索头文件目录,默认/usr/include
// gcc sin.c -lm -I/usr/include

```

# make大型编译
https://www.gnu.org/software/make/manual/make.html

```bash

vi makefile
# 目标: 目标文件1 目标文件2
# <tab> 执行命令
# 井号注释
main: main.o haha.o sin_value.o cos_value.o
	gcc -o main main.o haha.o sin_value.o cos_value.o -lm
clean:
	rm -f main main.o haha.o sin_value.o cos_value.o

make clean # 执行clean目标
make main # 编译
make clean main # 清空再编译

# 变量用=,并且空格隔开,左边不能有<tab>,最好用大写字母
# 使用变量用${}或$(),$@表示当前目标
vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
main: ${OBJS}
    gcc -o main ${OBJS} ${LIBS}
    gcc -o $@ ${OBJS} ${LIBS}
clean:
    rm -f main ${OBJS}

# 在shell中也能使用变量
CFLAGS="-Wall" make clean main # make进行编译,读取CFLAGS变量内容
# make指令后的变量最优先,其次是makefile文件指定的变量,shell变量第三优先

vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
CFLAGS = -Wall
main: ${OBJS}
    gcc -o $@ ${OBJS} ${LIBS}
clean:
    rm -f main ${OBJS}


```




# Tarball


从网络获取软件
```bash
# wget 下载软件
# -S print server response
# -O write documents to file
wget https://github.com/xxx.tar.gz -SO aaa.tar.gz

```

把源代码压缩成tar.gzip, tar.gz, tar.bz2, tar.tgz, tar.xz格式的文件,可以节省网络资源,下载速度加快.
源代码编译安装软件, Tarball包进行软件安装. 每次安装软件都需要检测操作系统与环境, 设置编译参数, 实际编译还要根据个人喜好安装软件并定制.
解压缩Tarball压缩包,可以得到源代码,环境检测configure/config等文件,软件的简略说明INSTALL,README.根据这两个文件的步骤便能编译软件.
也可以将预先编译好的软件包可以进行安装升级,升级软件可以获得,新功能,安全补丁,性能提升.
打开网站找到Tarball下载到本地,解压缩得到源代码,用gcc/make编译得到二进制文件

gcc/cc/Compiler: C语言编译器,现在很多Linux平台的源代码就是以gcc为基础来设计的.
make/autoconfig: 简化编译流程
Library/Include: 软件开发时直接调用库函数,尤其是驱动程序网卡,声卡,USB等,这些相关功能都被包含在kernel-source或kernel-header这些软件名称当中.
~/rpmbuild/SOURCE放原始档(tarball)和修复文件(patch file)
编译的步骤是, ./configure, make, make check, make install

安装步骤
解压缩, 将tarball文件在/usr/local/src解压缩
查看README或INSTALL文件
依赖软件安装, 根据上一步文件指示安装好一些依赖软件
configure/config自动检查系统环境, 建立makefile文件, 是开发者写的scripts
make clean, 源码里面有可能含有上次编译完成的.o目标文件
make, 根据Makefile文件
make install, 根据Makefile文件的install这个target指定内容
man page写入到/etc/man_db.conf

软件大多在/usr, 用户安装的软件在/usr/local里面, man在/usr/local/man里面, src在/usr/local/src里面
比如, apache软件有以下文件, 
/etc/httpd 配置文件, 
/usr/lib 函数库, 
/usr/bin 执行文件, 
/usr/share/man 说明文件
默认安装位置是/usr/local
/usr/local/etc
/usr/local/bin
/usr/local/lib
/usr/local/man
指定路径安装, 这样升级或者卸载软件就很方便
/usr/local/apache/etc
/usr/local/apache/bin
/usr/local/apache/lib
/usr/local/apache/man
其次, 将/usr/local/apache/bin加入到PATH中

tarball建议, 最好将tarball解压到/usr/local/src中, 最好安装到/usr/local默认路径下, 如果卸载最好将软件单独安装在/usr/local, 因为安装到单独目录, 所有需要在/etc/man_db.conf写入 MANPATH_MAP /usr/local/software/bin /usr/local/software/man

```bash

# 范例ntp, /root目录下有ntp-4*.tar.gz文件, 解压缩到/usr/local/src, 安装到/usr/local/ntp目录中
cd /usr/local/src # 切换目录
tar -zxvf /root/ntp-4.2.8p3.tar.gz # 解压缩
cd ntp-4.2.8p3
vi INSTALL(README) # 了解一下安装流程
./configure --help | more # 查看可用参数
./configure --prefix=/usr/local/ntp --enable-all-clocks --enable-parse-clocks # 建立makefile
make clean; make
make check
make install
cd /usr/local/ntp | ls -al # 软件安装完毕

```


更新软件不必下载新的tarball, 而是通过patch更新源代码, 重新编译
用diff/patch指令生成新的文件

```bash
# 旧版文件正常使用
tar -zxvf main-0.1.tgz
cd main-0.1
make clean main
./main

# 查看patch
vim ~/main_0.1_to_0.2.patch # 有内容

patch -p1 < ../main_0.1_to_0.2.patch # 更新源代码
make clean main
./main # 软件变了
make install # 安装到通用路径
main
make uninstall # 卸载

patch -R < ../main_0.1_to_0.2.patch # 可以还原源代码


```




# 函数库管理

很多软件之间都彼此提供函数库进行特殊功能的运行
静态(Static)函数库, libxxx.a扩展名为.a, 在编译时整合到程序中, 程序可以独立执行, 升级函数库程序需要重新编译
动态(Dynamic)函数库, libxxx.so扩展名为.so, 程序会指向函数库路径, 执行时才会使用到函数库, 不能独立执行, 升级时直接升级函数库即可
Linux偏向于使用动态函数库, 大多都放在/lib64,/lib目录下, kernel函数库放在/lib/modules里面

将动态函数库加载到内存中, 提高软件执行时间, 将动态函数库的目录写入到/etc/ld.so.conf, 然后用ldconfig命令加载到内存中, 数据库也被记录在/etc/ld.so.cache文件中
可以自己将Tarball安装到函数库中, 可以将目录路径写入到/etc/ld.so.conf.d/yourfile.conf中, 然后可以执行ldconfig

```bash
# ldconfig 配置文件在/etc/ld.so.conf
# -f 后接conf, 用conf作为libarary函数库的路径,而不是/etc/ld.so.conf
# -C 后接cache, 某个文件名称, 使用cache作为内存函数库数据, 而不是/etc/ld.so.cache
# -p 列出目前有的所有函数库数据内容, 在/etc/ld.so.cache
vim /etc/ld.so.conf.d/vbird.conf # 添加一行/usr/lib64/mysql
ldconfig # 正常没有任何信息
ldconfig -p # 函数库名称, 函数库实际路径

# ldd 程序的动态函数库解析, 分析程序使用的函数库
# -v 列出所有内容
# -d 重新将数据link展示出来
# -r 将ELF有关的内容展示出来
ldd /usr/bin/passwd # 分析文件的函数资料
ldd -v /lib64/libc.so.6 # 找出这个函数库的相关函数库

```




# 文件的MD5

下载的软件与官网做对比, 就能知道是不是被篡改
通过MD5m, sha1, sha256指纹验证机制就能知道软件是否有变化


```bash
# md5sum/sha1sum/sha256sum filename
# -b 使用binary读取方式, 默认为Windows/DOS读取方式
# -c 检验文件指纹
# -t 以文字形态来读取文件指纹
md5sum ntp-4.2.8p3.tar.gz
b98b0cbb72f6df04608e1dd5f313808b  ntp-4.2.8p3.tar.gz

# 或许你可以把经常被容易被攻击的文件MD5记录下来, 不时检查一下
/etc/passwd
/etc/shadow
/etc/group
/usr/bin/passwd
/sbin/rpcbind
/bin/login
/bin/ls
/bin/ps
/bin/top

```













# 包管理工具
Linux发行版官方针对自己的平台先进行编译等过程,然后将编译好的二进制程序发布,与我们系统的Linux环境相同,所以可以直接安装,跳过了检测环境和编译的过程, 将这个软件直接给用户安装.
在安装时加入一些程序信息, 建立成程序库, 就可以进行安装,卸载,升级和验证等相关功能.
将可执行文件打包成软件档案, 用户通过指令安装, 安装必须符合安装环境需求. 安装完成后还会将信息写入软件管理机制中, 完成后来的升级移除等动作.
dpkg apt(apt-get), 最早是由Debian Linux社区开发, Debian的dpkg机制能够安装软件, 包括B2D, Ubuntu.
RPM(rpm,rpmbuild) yum, 是由RedHat开发出来的, 很多发行版就用这个机制作为软件安装的管理方式, 包括RedHat, Fedora, CentOS, SuSE等.
软件都有互相依赖的问题, 包管理工具会先安装被依赖的软件, 线上升级机制, dpkg有APT, RPM有yum, SuSE有YOU(Yast Online Update).




## RPM与YUM

rpm(Redhat Package Manager)命令是RPM软件包的管理工具,RPM原本是RedHatLinux发行版专门用来管理Linux各项套件的程序,它遵循GPL规则且功能强大方便,所以广受欢迎,让linux易于安装升级提升了linux适用度.
将你要安装的软件先编译过, 并且打包成RPM机制包装文件, 软件文件安装环境必须与打包时环境需求一致或相似, 记录这个软件需要安装的相关属性的软件, 安装后将软件写入数据库中. 预先编译且打包好,软件传输与安装很方便,软件信息被记录在数据库中,方便查询升级和卸载. 卸载时要小心, 最底层的软件不可先卸载, 否则可能造成系统问题.
RPM安装包可以直接安装, 不包含源代码, 但是不能修改参数并编译.
SRPM是Source RPM的意思, RPM文件中含有原始代码, SRPM文件以.src.rpm结尾, 通过修改SRPM内的参数设置才能产生适合我们的Linux环境的RPM文件, 不仅含有RPM的依赖信息和说明文件, 还有源代码的configure与makefile. 先将该软件以RPM管理方式编译, 然后SRPM会被编译成RPM文件, 然后将编译完成的RPM文件安装到Linux系统中.
rp-pppoe-3.11-5.el7.x86_64.rpm, rp-pppoe(软件名称)-3.11(软件版本主版本次版本)-5(发行版序号可能修复了小漏洞).el7.x86_64(硬件平台).rpm(拓展名).
硬件平台, i386(几乎适用于所有x86平台) i586(稍微高级的CPU) i686(高级CPU) x86_64(64位CPU最优设置) noarch(没有硬件等级的限制,一般没有二进制程序,只是shell script软件)
rpm必须先安装依赖软件才能装目标软件, 这一步骤是由软件管理器数据库来记录的, 为了解决依赖关系, 使用yum来解决. yum去服务器仓库中去找所有需要的软件, 然后再安装需要的软件. 软件数据列表/var/cache/yum, 安装完毕后信息写入到/var/lib/rpm目录下查询已下载软件的来源,数字签名也在这里.
rpm包默认安装的路径, /etc 配置文件, /usr/bin 可执行命令, /usr/lib 程序所使用的函数库保存位置, /usr/share/doc 基本软件使用手册, /usr/share/man 帮助文件


```bash
# rpm命令只剩下查询和检验的功能, 其他功能都是yum来操作
# rpm RPM包管理工具
# -i install
# -v 显示详细信息
# -h 打印#,显示安装进度
# -U 升级安装,没安装则安装,低版本换成高版本
# -F 升级安装,没安装就不安装,必须要低版本才升级
rpm -i package_name.rpm name2.rpm # 安装软件
rpm -ivh http://website.name/path/pkgname.rpm # 网络安装
rpm -ivh package_name # 安装包,已有则报错
rpm -Uvh package_name # 安装或升级
rpm -Fvh package_name # 只升级
rpm -e package_name # 卸载包,依赖性从高到低卸载
# rpm其他选项
# --nodeps 不考虑依赖问题强制安装, 可能无法使用
# --replacefiles 报已安装软件,直接覆盖原文件安装
# --replacepkgs 重复安装已安装过的软件
# --force replacefiles与replacepkgs的综合体
# --test 测试软件依赖问题与环境问题
# --justdb 修复RPM数据库或者其他错误
# --nosignature 忽略数字签名的检查
# --prefix newpath 将软件安装到其他目录
# --noscripts 不想在安装过程中执行某些系统指令

# 查询query功能, 软件列表数据库/var/lib/rpm, 也可以查询到未安装的软件信息
# -q 仅查询, 后接软件名称, 是否安装
# -qa 列出所有, 已经安装在本机Linux系统上所有软件名称
# -qi 列出该软件的详细信息, 包含厂商,版本说明
# -ql 列出软件所有文件与目录所在的完成文件名
# -qc 列出该软件的所有配置文件(在/etc下的文件)
# -qd 列出该软件的所有说明文件(man有关的文件)
# -qR 列出该软件有关的依赖软件的文件(Required的缩写)
# -qf 后接文件名称, 找出该文件属于哪个已安装的软件
# -q --script 列出是否含有安装后需要执行的脚本文件,可以用debug
# -qp[icdlR] 查询.rpm文件内含有的信息, 并不是已安装的软件信息, (p是package的缩写)
rpm -qa 已安装的软件
rpm -q[licdR] 已安装软件名
rpm -qf 系统上的文件名称
rpm -qp[licdR] 未安装的某个文件名称
rpm -q logrotate # 查询软件是否安装
rpm -ql logrotate # 属于该软件所提供的所有目录与文件
rpm -qi logrotate # 列出logrotate的相关说明资料
rpm -qc logrotate # 配置文件
rpm -qd logrotate # 说明文件
rpm -qR logrotate # 如果要安装软件, 需要依赖什么文件
rpm -qf /bin/sh # 是由哪个文件提供的
rpm -qpR filename.i386.rpm # 列出该文件的依赖文件
rpm -qa | grep ^c | wc -l # 系统中以c开头的软件有几个
rpm -qc httpd # 寻找配置文件
rpm -ivh http://website.name/path/httpd-x.x.x.i386.rpm --replacepkgs # 重新安装软件覆盖配置文件, 假设你的配置文件被改错了
rpm -qf /etc/crontab # 误删掉配置文件, 想知道是哪个软件的

# 验证和数字签名(Verify/signature)
# 验证/var/lib/rpm数据列表与系统软件是否一致, 可以修复误删或者丢失的问题, 也可以知道哪些文件被修改过.
# -V 后接软件名称, 如果软件所含的文件被修改, 才会被列出来
# -Va 列出目前系统上所有可能被修改的文件
# -Vp 后加文件名称, 列出该软件内可能被修改的文件
# -Vf 列出某个文件是否被修改
rpm -V 已安装的软件名称
rpm -Va
rpm -Vp 某个RPM文件的文件名
rpm -Vf 在系统上面的某个文件
rpm -V logrotate # 如果没有输出, 说明没有被修改过
rpm -Vf /etc/crontab # 被修改过, 列出被修改的信息类型
rpm -V logrotate # 如果修改配置文件, 然后就会输出信息了
SM5DLUGTP c/d/g/l/r filename # 文件信息 文件类型 文件名
# 文件信息
# S(file Size differs) 文件容量大小是否被修改
# M(Mode differs) 文件的类型或者属性是否被修改
# 5(MD5 sum differs) MD5是否不同
# D(Device major/minor number mis-match) 设备主/次代码已经改变
# L(readLink(2) path mis-match) Link路径是否被改变
# U(User ownership differs) 文件的拥有者是否被改变
# G(Group ownership differs) 文件的群组是否被改变
# T(mTime differs) 文件的建立时间是否被改变
# P(caPabilities differ) 功能是否被改变
# 文件类型
# c 配置文件
# d 文档
# g 幽灵文件ghost file, 该文件不被软件包含, 很少发生
# l 授权文件 license file
# r 读我文件 readme
# 数字签名, 厂商发布软件会带有数字签名, 对比之后才会安装, CentOS数字签名是由GNU计划的GnuPG(GNU Privacy Guard,GPG)提供, 可以忽略数字签名安装软件
ls -l/cat /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 # CentOS7的数字签名位置
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 # 安装数字签名
locate GPG-KEY # 寻找大多数软件的GPG-KEY文件(密钥)
find /etc -name '*GPG-KEY*' # 寻找大多数软件的GPG-KEY文件
rpm -qa | grep pubkey # 查询密钥名称
rpm -qi gpg-pubkey-f4a80eb5-53a7ff4b # 软件信息

# 卸载与重建数据库
# - e 卸载, 由依赖顺序从上往下卸载
# --rebuilddb 重建数据库
rpm -qa | grep pam # 查询与pam有关的软件名称, 并尝试卸载
rpm -e pam # 直接卸载有依赖问题
rpm -e pam-devel # 不会有任何依赖问题
rpm -q pan-devel # 查无此软件
rpm --rebuilddb # 重建数据库

# 解压RPM包, 先转成cpio再解压
rpm2cpio xxx.rpm | cpio -div

```

yum通过分析RPM数据库, 根据依赖信息做出解决方案
yum软件仓库网址必须提前设定, 选择地理位置较近的镜像站点, 修改/etc/yum.repos.d/CentOS-Base.repo来修改配置

```bash
# yum 查询, 安装, 升级, 卸载
# -y 免去用户输入yes的选项
# --installroot=/some/path 将软件安装在指定路径
# search 搜索某个软件名称或者描述关键字
# list 列出目前yum所有软件的名称与版本, rpm -qa
# info 同上, 类似rpm -qai执行结果
# provides 从文件搜索软件, rpm -qf
# whatprovides 
yum search raid # 搜索磁盘阵列相关软件
yum info mdadm # 功能是啥
yum list # 列出yum服务器上面提供的所有软件名称
yum list updates # 列出软件库内可以升级的软件
yum list pam* # pam开头的软件, 其中未安装的软件有哪些
yum provides passwd # 提供这个文件的程序有哪些
# install 安装
# update 升级
# remove 卸载
yum install pam-devel # 安装软件, 首先输出最快的仓库, 接下来输出属性依赖问题
yum remove pam-devel # 卸载软件
# repolist 显示仓库所使用的软件库有哪些
yum repolist all # 显示yum仓库有哪些
# 修改配置文件后, 旧数据需要重新从仓库更新
# clean package 将已下载的软件文件删除
# clean headers 将下载的头文件删除
# clean all 将所有软件库数据都删除
yum clean all # 删除已下载的所有软件库相关数据

# 软件套件, 修改/etc/yum.conf可以定制软件套件
# grouplist 列出所有可使用的软件套件
# groupinfo 后接group_name, 可以了解套件内的所有软件名
# groupinstall 可以安装整套软件
# groupremove 卸载某个套件
yum grouplist # 列出当前软件套件
yum groupinfo "Scientific Support" # 科学支持套件的所有软件名
yum groupinstall "Development Tools" # 安装开发套件

```

第三方软件辅助, MPICH默认加入, NetCDF和统计软件R不在其中, 可以通过非Tarball安装
EPEL(Extra Packages for Enterprise Linux)是Fedora基金会发展的一个额外软件计划, 针对Redhat Enterprise Linux来开发的, CentOS也能用, 能够支持该软件仓库的系统环境
ELRepo软件仓库, 提供内核, 核心模块与虚拟化的软件相关.
安装软件时, 优先选择官方网站权威网站的原厂RPM, Tarball方式安装测试版新版软件, 如果依赖问题无法解决, 也可以用Tarball方式安装.

```bash
# 安装netcdf与R
vim /etc/yum.repos.d/epel.repo
[epel]
name = epel packages
baseurl = https://dl.fedoraproject.org/pub/epel/7/x86_64
gpgcheck = 0
enabled = 0
yum --enablerepo=epel install netcdf R # 启动epel仓库才安装

# 使用光盘安装软件
vim /etc/yum.repos.d/cdrom.repo
[mycdrom]
name = mycdrom 
baseurl = file:///mnt
gpgcheck = 0
enabled = 0
yum --enablerepo=mycdrom install software_name

# 用crontab自动update
echo '10 1 * * * root /usr/bin/yum -y --enablerepo=epel update' > /etc/cron.d/yumupdate
vim /etc/crontab

# 范例: 安装apache2
# yum install soft
# systemctl start soft
# systemctl enable soft
# firewall-cmd --add-service="your server"; firewall-cmd --permanent --add-service="your server"
# test your software
rpm -q httpd php mariadb-server php-mysql # 查看软件是否安装
yum install httpd php mariadb-server php-mysql # 安装软件
systemctl daemon-reload
systemctl start httpd
systemctl enable httpd
systemctl status httpd
firewall-cmd --add-service="http"
firewall-cmd --permanent --add-service="http"
firewall-cmd --list-all
http://localhost # 看看网页能不能打开

```

rpmbuild, SRPM是包含Source code的软件包
从不同Linux发行版下载的SRPM安装到自己的系统上
SRPM在进行编译的时候会在家目录进行, ~/rpmbuild/SPECS放置软件配置文件配置参数, ~/rpmbuild/SOURCES源代码tar.gz和config配置文件, ~/rpmbuild/BUILD在编译过程中,有些缓存文件都放在这里, ~/rpmbuild/RPMS编译成功之后,将打包完成的文件放这里,x86_64,noarch等子目录, ~/rpmbuild/SRPMS与RPMS类似,放置封装好的SRPM文件,发布SRPM软件,就放这里, 等编译工作全部完毕, 就只剩下~/rpmbuild/RPMS目录了
SRPM重新编译,过程中需要make及gcc,c,c++等编译器工具, 编译过程具体如下, 先进入到~rpmbuild/BUILD目录中, 按照.spec文件内的Name和Version定义的工作目录名称, 新建目录里面,针对SOURCES目录下的源文件,以tar进行解压缩, 再开始%build及%install设置与编译, 然后将完成打包的文件放置到指定位置, 如*.x86_64.rpm文件放置在rpmbuild/RPMS/x86_64里面



```bash

# rpmbuild
# --rebuild 编译和打包SRPM, 不安装, 输出RPM的绝对路径, 然后RPM就能安装了
# --recompile 编译打包和安装SRPM, 
wget http://vault.centos.org/7.1.1503/updates/Source/SPackages/ntp-4.2.6p5-19.el7.centos.1.src.rpm # 下载软件
rpmbuild --rebuild ntp-4.2.6p5-19.el7.centos.1.src.rpm # 直接编译
yum install libcap-devel openssl-devel libedit-devel pps-tools-devel autogen autogen-libopts-devel # 需要安装依赖
rpmbuild --rebuild ntp-4.2.6p5-19.el7.centos.1.src.rpm # 再次编译
/root/rpmbuild/RPMS/x86_64/ntp-4.2.6p5-19.el7.centos.1.x86_64.rpm # 软件位置
# 重新修改配置, 加入一些功能, 需要进行改动然后重新编译
# 范例: ntp的SRPM软件不编译直接安装到系统, 检查一下用到的目录
rpm -ivh ntp-4.2.6p5-19.e17.centos.1.src.rpm # 会有一堆warning, 暂时忽略
ll -l /root/rpmbuild # 检查一下/root/rpmbuild
ll -l /root/rpmbuild/{SOURCES,SPECS} # SPECS/ntp.spec很重要
vim ntp.spec # 配置文件和配置信息
rpmbuild -ba ntp.spec # 编译并同时产生RPM与SRPM文件
rpmbuild -bb ntp.spec # 仅编译成RPM文件
find /root/rpmbuild -name 'ntp*rpm'

# 范例: 打包自己的软件
/root/rpmbuild/SOURCES/main-0.1.tar.gz
/root/rpmbuild/SOURCES/main_0.1_to_0.2_patch
/root/rpmbuild/SPECS/main.spec
cd /root/rpmbuild/SOURCES
wget http://linux.vbird.org/linux_basic/0520source/main-0.1.tgz
wget http://linux.vbird.org/linux_basic/0520source/main_0.1_to_0.2.patch
ll main* # 下载好的两个文件
cd /root/rpmbuild/SPECS
vim main.spec # 配置文件, 这个文件很重要
rpmbuild -ba main.spec # 编译文件, 上面的文件很重要
yum install /root/rpmbuild/RPMS/x86_64/main-0.1-1.el7.centos.x86_64.rpm
rpm -ql main # 自己尝试执行main看看
rpm -qi main # 查看自己的软件是否成功安装

```




## DPKG与APT






```bash



sudo add-apt-repository ppa:ubuntuhandbook1/darktable # add ppa




```


## snap

https://snapcraft.io/
https://snapcraft.io/docs


```bash

apt-get install snap # 安装snap
# snap Snap包是Ubuntu16.04发布时引入的新应用格式包
snap install code --classic # 安装code snap
snap remove code # 卸载snap
snap find code # 搜索snap
snap info code # 查看snap信息
snap list # 查看已安装的snap
snap refresh
snap refresh code channel=latest/stable # 更新snap, channel来指定通道版本
snap install snapcraft –classic # 成为snap开发者


```


# 参考手册

```bash

# --help 获取应用程序的内置命令
man --help

# man 手册
# /usr/share/man 默认位置 /etc/man_db.conf配置文件存放地址
# space 向下翻一页
# PageDown 向下翻一页
# PageUp 向上翻一页
# HOME 第一页
# END 最后一页
# /向下搜索字符串
# ?向上搜索字符串
# n,N 查询下一个 摁住shift变成大写查询上一个
# q 退出man
# 1一般使用者可使用的指令
# 2系统内核可调用的函数与工具
# 3常用函数与函数库,大部分为C函数库
# 4设备文件的说明,一般是/dev下的文件
# 5文件格式或者是文件的格式
# 6游戏
# 7惯例与协议,比如Linux文件系统,网络协议,ASCII code等
# 8系统管理员命令,一般是root账户
# 9与内核有关的文件
# NAME 简短的命令/资料名称说明
# SYNOPSIS 简短的命令使用说明
# DESCRIPTION 较为完整的说明
# OPTIONS 针对SYNOPSIS部分,列举所有的可用选项说明
# COMMANDS 软件运行期间,可以使用的命令
# FILES 这个命令或者资料相关的某些文件
# SEE ALSO 可以参考的其他相关指令
# EXAMPLE 一些参考范例
# -f 简短描述 类似于whatis man
# -k 搜索名称和简短描述带有的关键字 apropos
man 1 man # 默认打开数字较小的
man 7 man # 资料
man -k man # 含有名称和简短描述带有man的内容
man date
man null # 设备文件4
/date # 进入手册搜索关键字并高亮显示

# info 包含的信息比man还要多
# /usr/share/info
# 如果没有info信息,则会以man格式页面展示 info man
# File表示这个资料是info.info文件提供的
# Node表示这个页面属于top节点
# Next表示下一个节点名称是Getting Started,N到达下一个节点
# Prev表示前一个节点,P到达上一个节点
# Up表示上一层节点,U回到上一层
# 整个层级结构dir在最上层,info在第一层,Getting started在第二层,Help在第三层
# *带星号的属于超链接,tab键能快速切换
# Enter进入*的超链接
# space 下一页
# b 移动光标到第一个字符
# e 移动光标到最后一个字符
# n 前往下一个节点
# p 前往上一个节点
# u 向上移动一层
# s /在页面中查找
# h,? 帮助菜单
# q 退出

# 其他文档信息
# /usr/share/doc 找到软件信息

# whatis 获取简要说明,相当于man -f
# apropos 通过关键字查找定位手册页的名字和描述,相当于man -k

```





# 有趣的Linux命令

```bash

# sl 跑火车
# fortune 随机输出名言
# cowsay 奶牛打印文字
# xcowsay 升级版的奶牛打印文字
# cmatrix 黑客帝国风格
# figlet toilet 艺术字体
# rev 颠倒输出字符串
# toilet -f mono12 -F gay AAAA
# oneko 一只猫跟着鼠标动
# xeyes 一只眼睛跟着鼠标动
# yes 无限输出文字
# shred 文件粉碎
# factor 分解质因数
# aptitude 可能跟apt有关
aptitude moo
aptitude -v moo
aptitude -vv moo
aptitude -vvv moo
aptitude -vvvv moo
# aafire 火焰 libaa-bin
# hollywood
# byobu 仪表盘
# echo "aaa" | boxes -d dog
# htop 任务管理器
# bastet 俄罗斯方块
# screenfetch 系统信息
# linuxlogo linux标志
linuxlogo -f -L list # 30个花样
for i in {1..30};do linuxlogo -f -l $i;sleep 0.2;done

# aview imagemagick asciiview 图片输出
# cat /etc/passwd | pv -qL 10 手打输出文件

# apt moo 驴子 apt --help 具有超级牛力
# bb 一个字符艺术demo

```






































