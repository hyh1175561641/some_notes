
# 注册中心






# Eureka

https://github.com/Netflix/eureka

Eureka-Server:记录和管理微服务
Eureka-Client:服务提供者和服务消费者都属于客户端,每个Client会把自己的信息注册给Eureka,每隔30秒向注册中心发送一次心跳信息,确认本机的状态,否则会从列表中剔除,这样就感知到了微服务的健康状态
当服务消费者想要一项服务时,会向注册中心寻找服务,注册中心寻找到信息再提供给服务消费者,然后服务消费者再向服务提供者发起请求.如果有多个服务提供者,Eureka用负载均衡的算法,从服务列表中挑选一个返回给消费者
Eureka自己本身也是一个微服务,它会把自己也注册到Eureka上面.如果有三个Eureka,那么这三个Eureka也会相互注册,这样就能相互交流了

```java
//Eureka注册中心
//创建独立模块

// web起步依赖
org.springframework.boot:spring-boot-starter-web
// Eureka服务端
org.springframework.cloud:spring-cloud-starter-netflix-eureka-server:2.2.1.RELEASE

/*
# Tomcat
server.port: 9099
# Spring
spring:
  application:
    # 应用名称
    name: eureka-demo
eureka:
  client:
    sevice-url: # eureka的地址信息
      defaultZone: http://localhost:${server.port}/eureka
    register-with-eureka: false
    fetch-registry: false

*/

@EnableEurekaServer
@SpringBootApplication
public class EurekaApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
/*
# Eureka客户端
org.springframework.cloud:spring-cloud-starter-netflix-eureka-client

server:
  port: 9080
spring:
  application:
    name: servicedemo
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cloud_project
    username: "root"
    password: "0000"
eureka.client.service-url.defaultZone: http://localhost:9099/eureka
*/

//向注册中心发起请求,更改成服务的名称
String url = "http://localhost:8090/user/"+order.getUserId();
String url = "http://userservice/user/"+order.getUserId();




```

```java
//Ribbon负载均衡,对符合名称的服务产生调用
//请求会被负载均衡拦截器拦截LoadBalancerInterceptor,然后从服务列表中选择一个进行返回

//RoundRobinRule 简单轮询,默认规则
//WeightedResponseTimeRuld 权重轮询
//ZoneAvoidanceRuld 以区域可用的服务器为基础进行服务器的选择
//BestAvailableRule 
//RandomRule随机选择
//RetryRule重试机制的选择逻辑

@Bean
@LoadBalanced//负载均衡注解
public RestTemplate restTemplate() {
    return new RestTemplate();
}

@Bean//负载均衡策略 全体服务
public IRule randomRule(){
    return new RandomRule();
}

/*
userservice:
  ribbon: # 负载均衡规则 某一个服务
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
*/

//负载均衡默认采用懒加载,第一次访问才会去创建LoadBalanceClient,请求时间会很长,饥饿加载则会在项目启动时创建,降低第一次访问的耗时,通过下面配置开启饥饿加载
/*
ribbon:
  eager-load:
    enabled: true # 开启饥饿加载
      clients: userservice # 指定对userservice这个服务饥饿加载

*/



```








# Nacos

https://nacos.io/zh-cn/
https://nacos.io/zh-cn/docs/what-is-nacos.html
https://github.com/alibaba/nacos/
https://spring.io/projects/spring-cloud-alibaba

一个更易于构建云原生应用的动态服务发现(Nacos Discovery),服务配置(Nacos Config)和服务管理平台.
特性: 服务发现和服务健康监测,动态配置服务,动态DNS服务,服务及其元数据管理.

阿里巴巴产品,现在成为了SpringCloud的一个组件,比Eureka功能更加丰富,国内比较受欢迎,其中健康监测多了很多机制
服务的注册和发现

Service registration and discovery：instances can be registered with Alibaba Nacos and clients can discover the instances using Spring-managed beans. Supports Ribbon, the client side load-balancer via Spring Cloud Netflix
分布式配置
Distributed Configuration：using Alibaba Nacos as a data store


```java
// 官方推荐版本 2.1.1
// 下载windows安装包nacos-server-1.4.1.zip,解压,
//默认端口8848
//运行startup.cmd -m standalone开启



// 父工程
// springCloud依赖
org.springframework.cloud:spring-cloud-dependencies:Hoxtom.SR10:type=pom:scope=import;
// nacos管理依赖
com.alibaba.cloud:spring-cloud-alibaba-dependencies:2.2.5.RELEASE:type=pom:scope=import;

把服务注册到Nacos注册中心,会弹出一个页面
spring.cloud.nacos.server-addr: localhost:8858


// 子工程,在order和user模块中添加依赖
// Nacos依赖
com.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery
yaml:spring.cloud.nacos.server-addr: localhost:8848 // nacos服务地址



```
负载均衡,默认根据轮询进行配置,也能根据权重进行负载均衡,权重大的负载的频率高,权重为0不进行访问（这时候可以进行服务的升级）

环境隔离：namespace为了管理数据和服务,可以把服务分开的机制
Namespace-Group-Service/Data-集群-实例


配置更改热更新,Nacos统一管理微服务,微服务读取注册中心的配置,然后与本地配置结合起一起使用,项目将来的nacos中的配置文件会和本地的application.yml合并起来配置服务




Nacos概念

地域: 物理的数据中心,资源创建成功后不能更换.
可用区: 同一地域内,电力和网络互相独立的物理区域.同一可用区内,实例的网络延迟较低.
接入点: 地域的某个服务的入口域名.
命名空间: 用于进行租户粒度的配置隔离.不同的命名空间下,可以存在相同的 Group 或 Data ID 的配置.Namespace 的常用场景之一是不同环境的配置的区分隔离,例如开发测试环境和生产环境的资源（如配置、服务）隔离等.

配置: 在系统开发过程中,开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理,以独立的配置文件的形式存在.目的是让静态的系统工件或者交付物（如 WAR,JAR 包等）更好地和实际的物理运行环境进行适配.配置管理一般包含在系统部署的过程中,由系统管理员或者运维人员完成.配置变更是调整系统运行时的行为的有效手段.
配置管理: 系统配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动.
配置项: 一个具体的可配置的参数与其值域,通常以 param-key=param-value 的形式存在.例如我们常配置系统的日志输出级别（logLevel=INFO|WARN|ERROR） 就是一个配置项.
配置集: 一组相关或者不相关的配置项的集合称为配置集.在系统中,一个配置文件通常就是一个配置集,包含了系统各个方面的配置.例如,一个配置集可能包含了数据源、线程池、日志级别等配置项.
配置集 ID: Nacos 中的某个配置集的 ID.配置集 ID 是组织划分配置的维度之一.Data ID 通常用于组织划分系统的配置集.一个系统或者应用可以包含多个配置集,每个配置集都可以被一个有意义的名称标识.Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则保证全局唯一性.此命名规则非强制.
配置分组: Nacos 中的一组配置集,是组织配置的维度之一.通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组,从而区分 Data ID 相同的配置集.当您在 Nacos 上创建一个配置时,如果未填写配置分组的名称,则配置分组的名称默认采用 DEFAULT_GROUP .配置分组的常见场景：不同的应用或组件使用了相同的配置类型,如 database_url 配置和 MQ_topic 配置.
配置快照: Nacos 的客户端 SDK 会在本地生成配置的快照.当客户端无法连接到 Nacos Server 时,可以使用配置快照显示系统的整体容灾能力.配置快照类似于 Git 中的本地 commit,也类似于缓存,会在适当的时机更新,但是并没有缓存过期（expiration）的概念.

服务: 通过预定义接口网络访问的提供给客户端的软件功能.
服务名: 服务提供的标识,通过该标识可以唯一确定其指代的服务.
服务注册中心: 存储服务实例和服务负载均衡策略的数据库.
服务发现: 在计算机网络上,（通常使用服务名）对服务下的实例的地址和元数据进行探测,并以预先定义的接口提供给客户端进行查询.

元信息
Nacos数据（如配置和服务）描述信息,如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label),从作用范围来看,分为服务级别的元信息、集群的元信息及实例的元信息.

应用
用于标识服务提供方的服务的属性.

服务分组
不同的服务可以归类到同一分组.

虚拟集群
同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分,划分的单位可以是虚拟集群.

实例
提供一个或多个服务的具有可访问网络地址（IP:Port）的进程.

权重
实例级别的配置.权重为浮点数.权重越大,分配给该实例的流量越大.

健康检查
以指定方式检查服务下挂载的实例 (Instance) 的健康度,从而确认该实例 (Instance) 是否能提供服务.根据检查结果,实例 (Instance) 会被判断为健康或不健康.对服务发起解析请求时,不健康的实例 (Instance) 不会返回给客户端.

健康保护阈值
为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ,继而造成流量压力把健康实例 (Instance) 压垮并形成雪崩效应,应将健康保护阈值定义为一个 0 到 1 之间的浮点数.当域名健康实例数 (Instance) 占总服务实例数 (Instance) 的比例小于该值时,无论实例 (Instance) 是否健康,都会将这个实例 (Instance) 返回给客户端.这样做虽然损失了一部分流量,但是保证了集群中剩余健康实例 (Instance) 能正常工作.

