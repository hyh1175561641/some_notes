

# 服务异步通讯

同步通讯: 微服务基于Feign的调用就属于同步方式,时效性强,可以立即得到结果.缺点:耦合度高,每次加功能都要修改代码.性能下降,需要等待任务全部执行完成.浪费资源,高并发场景极度浪费.级联失败,服务提供者出现问题,调用方也会跟着出现问题,迅速导致整个微服务群故障.

异步通讯: 时效性不太好,事件驱动模式,把事件交给事件代理者Broker,通知服务执行叫做事件订阅。主服务发送事件给Broker,然后通知辅助服务执行。
优点服务解耦,新增或删除功能不需要修改代码,性能提示吞吐量提高。没有依赖关系,服务挂机也不影响服务。流量削峰,管理请求数量,暂时存储突发大量的流量.

异步通信的缺点：依赖于Broker的可靠性,安全性,吞吐能力。架构复杂了,业务没有明显的流程线,不好追踪管理

MQ(MessageQueue) 消息队列,存放消息的队列,FIFO先入先出,也就是事件驱动架构中的Broker.跨进程的通信机制,用于上下游传递消息,在互联网架构中,MQ是一种非常常见的上下游消息通信服务+逻辑解耦+物理解耦.使用MQ之后,消息发送上游只需要依赖MQ,不需要依赖其他服务.

四种常见的MQ,RabbitMQ,ActiveMQ,RocketMQ,Kafka.

其中kafka吞吐量最高,RabbitMQ消息延迟最低是微秒级,RabbitMQ消息可靠性最高.

Erlang语言是面向并发的编程语言,天生为分布式系统而设计








# SpringAMQP

https://spring.io/projects/spring-amqp

AMQP(Advanced Message Queuing Protocol),是用于在应用程序或之间传递业务消息的开方标准。该协议与语言和平台无关,更符合微服务中独立性的要求

Spring AMQP 是基于AMQP协议定义的一套API规范,提供了模板来发送和接收消息.包含两部分,其中spring-amqp是基础抽象,spring-rabbit是底层的默认实现.



侦听器容器,基于异步处理入站消息
用于发送和接收消息的RabbitTemplate
RabbitAdmin用于自动声明队列,交换和绑定



```java
// 导入依赖
// org.springframework.amqp:spring-rabbit:2.4.10



```


































# Kafka

https://kafka.apache.org/
https://kafka.apache.org/documentation/


大数据领域内的消息传输,绕不开Kafka,这款为大数据而生的消息中间件,以其百万级TPS的吞吐量名声大噪,迅速成为大数据领域的宠儿,在数据采集,传输,存储的过程中发挥着举足轻重的作用,目前已被LinkedIn,Uber,Twitter,Netflix等大公司所采纳.
优点,性能卓越,单机写入TPS约在百万条/秒,吞吐量高,时效性ms级可用性非常高,kafka是分布式的,一个数据多个副本,少数机器宕机,不会丢失数据,不会导致不可用,消费者采用Pull方式获取消息,消息有序,通过控制能够保证所有消息被消费且仅被消费一次.有优秀的第三方Kafka Web管理界面Kafka-Manager,在日志领域比较成熟,被多家公司和多个开源项目使用,功能支持:功能较为简单,主要支持简单的MQ功能,在大数据领域的实时计算以及日志采集被大规模使用.
缺点:Kafka单机超过64个队列/分区,Load会发生明显的飙高现象,队列越多,load越高,发送消息响应时间变长,使用轮询方式,实时性取决于轮询间隔时间,消费失败不支持重试,支持消息顺序,但是一台代理宕机后,就会产生消息乱序,社区更新较慢.








# ActiveMQ

https://activemq.apache.org/
https://activemq.apache.org/version-5-getting-started.html
https://github.com/apache/activemq


单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据.比较老,最早的MQ.
缺点:官方社区现在对ActiveMQ5.x维护越来越少,高吞吐量场景较少使用.





# RocketMQ

RockerMQ出自阿里巴巴的开源产品,用Java语言实现,在设计时参考了Kafka,并做出了自己的一些改进,被阿里巴巴广泛应用在订单,交易,充值,流计算,消息推送,日志流式处理,binglog分发等场景.尤其是电商里订单扣款,以及大量交易涌入,后端可能无法及时处理情况,在稳定性上更值得信赖,在阿里双十一已经经历了多次考验.
优点:单机吞吐量十万级,可用性非常高,分布式架构,消息可以做到0丢失,MQ功能较为完善,还是分布式的,扩展性好,支持10亿级别的消息堆积,不会因为堆积导致性能下降,源码是java我们可以自己阅读源码,定制自己公司的MQ.
缺点:支持的客户端语言不多,目前是java及C++,其中c++不成熟;社区活跃度一般,没有在MQ核心中去实现JMS等接口,有些系统要迁移需要修改大量代码.
使用量逐渐下降









