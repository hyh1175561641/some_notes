
# 网关

https://spring.io/projects/spring-cloud-gateway


请求地址过滤
对用户请求做身份认证，权限校验
将用户请求路由到微服务，并实现负载均衡
对用户请求做限流
保护微服务


# Gateway


```java

//gateway是基于Spring5中提供的WebFlux,属于响应式编程的实现，具备更好的性能。
//某些服务并不想对外公开，对用户的身份进行验证
//请求限流

//网关需要从注册中心拉取信息，然后进行负载均衡发起请求
//网关依赖
org.springframework.cloud:spring-cloud-starter-gateway
//nacos发现依赖
com.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery

/*
路由配置及nacos地址
server:
  port: 10010 # 网关端口
spring:
  application
    name: gateway
  cloud:
    nacos:
      server-addr: localhost:8848 # nacos地址
    gateway:
      routes: 网关路由配置
        - id: user-service # 路由id，自定义，只要唯一即可
#         uri: http://127.0.0.1:8081 # 路由的目标地址http就是固定地址
          uri: lb://userservice # 路由的目标地址lb就是负载均衡，后面跟服务名称
          predicates: #路由断言，也就是判断请求是否符合路由规则的条件
            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
          filters:  # 路由过滤器，处理请求或响应
        - id: order-service
          uri: lb://orderservice
          predicates:
            - Path=/order/** 
*/


//断言工厂，Spring提供了11种基本的Predicate工厂
//After,Before,Between,Cookie,Header,Host,Method,Path,Query,RemoteAddr,Weight

//GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。spring提供了31种不同的路由过滤器工厂。
/*
spring:
  cloud:
    gateway:
      routes: # 网关路由配置
        - id: user-service
          uri: lb://userservice
          predicates:
            - Path=/user/**
          filters:
            - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头
      default-filters: # 默认过滤器，会对所有的路由请求都生效
        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头
*/
//统一网关Gateway，全局过滤器 GlobalFilter，的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。
//区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。定义方式是实现GlobalFilter接口
public interface GlobalFilter{
  Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}

@Order(-1)//优先级最高
@Component
public class AuthorizeFilter implements GlobalFilter {
  public Mono<Void> filter(ServerWebExchange exchange, 
                           GatewayFilterChain chain) {
    //获取请求参数
    ServerHttpRequest request = exchange.getRequest();
    MultiValueMap<String,String> params = request.getQueryParams();
    //获取参数种的authorization参数
    String auth = params.getFirst("authorization");
    //判断参数值是否等于admin
    if("admin".equals(auth)){
      return chain.filter(exchange);//放行
    }
    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);//设置状态码401未登录
    return exchange.getResponse().setComplete();//拦截
  }
}

//网关执行顺序，当路由路径确定之后，匹配到的过滤器会生效，然后过滤器合并到一个过滤器链中(GatewayFilter集合)，排序后依次执行每个过滤器，每个过滤器必须指定一个int类型order值，order值越小，优先级越高，执行顺序越靠前
//GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定
//路由内的过滤器和defaultFilter的order由spring指定，默认是按照声明顺序从1递增
//当过滤器的order值一样,按照defaultFilter > 路由过滤器 > GlobalFilter顺序执行

/*
spring:
  cloud:
    gateway:
      globalcors: # 全局的跨域处理
        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题
        corsConfiguration:
          '[/**]':
            allowedOrigins: # 允许哪些网站的跨域请求
              - "http://localhost:8090"
              - "http://www.leyou.com"
            allowedMethods: # 允许的跨域ajax的请求方式
              - "GET"
              - "POST"
              - "DELETE"
              - "PUT"
              - "OPTIONS"
            allowedHeaders: "*" # 允许在请求中携带的头信息
            allowCredentials: true # 是否允许携带cookie
            maxAge: 360000 # 这次跨域检测的有效期
*/



```



# Zuul


```java
//zuul是基于Servlet的实现，属于阻塞式编程.










```









