





# Tetris

https://maicss.gitbook.io/pyqt5-chinese-tutoral/e-luo-si-fang-kuai-you-xi

俄罗斯方块游戏是世界上最流行的游戏之一。是由一名叫Alexey Pajitnov的俄罗斯程序员在1985年制作的，从那时起，这个游戏就风靡了各个游戏平台。

俄罗斯方块归类为下落块迷宫游戏。游戏有7个基本形状：S、Z、T、L、反向L、直线、方块，每个形状都由4个方块组成，方块最终都会落到屏幕底部。所以玩家通过控制形状的左右位置和旋转，让每个形状都以合适的位置落下，如果有一行全部被方块填充，这行就会消失，并且得分。游戏结束的条件是有形状接触到了屏幕顶部。

```
口口。。。。口口。。。。口。。。。。。口
口。。。。。。口。。。。口口。。。。口口
口。。。。。。口。。。。。口。。。。口

。口。。。。。口口。。。。。。。。
口口口。。。。口口。。。。口口口口
```

**具体实现**

没有图片，所以就自己用绘画画出来几个图形。每个游戏里都有数学模型的，这个也是。

用`QtCore.QBasicTimer()`创建一个游戏循环；模型是一直下落的；模型的运动是以小块为基础单位的不是按像素；从数学意义上来说，模型就是就是一串数字而已

代码由四个类组成：Tetris, Board, Tetrominoe和Shape。Tetris类创建游戏，Board是游戏主要逻辑。Tetrominoe包含了所有的砖块，Shape是所有砖块的代码。



```python
//pyqt
#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
ZetCode PyQt5 tutorial 

This is a Tetris game clone.

Author: Jan Bodnar
Website: zetcode.com 
Last edited: August 2017
"""

from PyQt5.QtWidgets import QMainWindow, QFrame, QDesktopWidget, QApplication
from PyQt5.QtCore import Qt, QBasicTimer, pyqtSignal
from PyQt5.QtGui import QPainter, QColor 
import sys, random

class Tetris(QMainWindow):

    def __init__(self):
        super().__init__()

        self.initUI()


    def initUI(self):    
        '''initiates application UI'''

        self.tboard = Board(self)
        self.setCentralWidget(self.tboard)

        self.statusbar = self.statusBar()        
        self.tboard.msg2Statusbar[str].connect(self.statusbar.showMessage)

        self.tboard.start()

        self.resize(180, 380)
        self.center()
        self.setWindowTitle('Tetris')        
        self.show()


    def center(self):
        '''centers the window on the screen'''

        screen = QDesktopWidget().screenGeometry()
        size = self.geometry()
        self.move((screen.width()-size.width())/2, 
            (screen.height()-size.height())/2)


class Board(QFrame):

    msg2Statusbar = pyqtSignal(str)

    BoardWidth = 10
    BoardHeight = 22
    Speed = 300

    def __init__(self, parent):
        super().__init__(parent)

        self.initBoard()


    def initBoard(self):     
        '''initiates board'''

        self.timer = QBasicTimer()
        self.isWaitingAfterLine = False

        self.curX = 0
        self.curY = 0
        self.numLinesRemoved = 0
        self.board = []

        self.setFocusPolicy(Qt.StrongFocus)
        self.isStarted = False
        self.isPaused = False
        self.clearBoard()


    def shapeAt(self, x, y):
        '''determines shape at the board position'''

        return self.board[(y * Board.BoardWidth) + x]


    def setShapeAt(self, x, y, shape):
        '''sets a shape at the board'''

        self.board[(y * Board.BoardWidth) + x] = shape


    def squareWidth(self):
        '''returns the width of one square'''

        return self.contentsRect().width() // Board.BoardWidth


    def squareHeight(self):
        '''returns the height of one square'''

        return self.contentsRect().height() // Board.BoardHeight


    def start(self):
        '''starts game'''

        if self.isPaused:
            return

        self.isStarted = True
        self.isWaitingAfterLine = False
        self.numLinesRemoved = 0
        self.clearBoard()

        self.msg2Statusbar.emit(str(self.numLinesRemoved))

        self.newPiece()
        self.timer.start(Board.Speed, self)


    def pause(self):
        '''pauses game'''

        if not self.isStarted:
            return

        self.isPaused = not self.isPaused

        if self.isPaused:
            self.timer.stop()
            self.msg2Statusbar.emit("paused")

        else:
            self.timer.start(Board.Speed, self)
            self.msg2Statusbar.emit(str(self.numLinesRemoved))

        self.update()


    def paintEvent(self, event):
        '''paints all shapes of the game'''

        painter = QPainter(self)
        rect = self.contentsRect()

        boardTop = rect.bottom() - Board.BoardHeight * self.squareHeight()

        for i in range(Board.BoardHeight):
            for j in range(Board.BoardWidth):
                shape = self.shapeAt(j, Board.BoardHeight - i - 1)

                if shape != Tetrominoe.NoShape:
                    self.drawSquare(painter,
                        rect.left() + j * self.squareWidth(),
                        boardTop + i * self.squareHeight(), shape)

        if self.curPiece.shape() != Tetrominoe.NoShape:

            for i in range(4):

                x = self.curX + self.curPiece.x(i)
                y = self.curY - self.curPiece.y(i)
                self.drawSquare(painter, rect.left() + x * self.squareWidth(),
                    boardTop + (Board.BoardHeight - y - 1) * self.squareHeight(),
                    self.curPiece.shape())


    def keyPressEvent(self, event):
        '''processes key press events'''

        if not self.isStarted or self.curPiece.shape() == Tetrominoe.NoShape:
            super(Board, self).keyPressEvent(event)
            return

        key = event.key()

        if key == Qt.Key_P:
            self.pause()
            return

        if self.isPaused:
            return

        elif key == Qt.Key_Left:
            self.tryMove(self.curPiece, self.curX - 1, self.curY)

        elif key == Qt.Key_Right:
            self.tryMove(self.curPiece, self.curX + 1, self.curY)

        elif key == Qt.Key_Down:
            self.tryMove(self.curPiece.rotateRight(), self.curX, self.curY)

        elif key == Qt.Key_Up:
            self.tryMove(self.curPiece.rotateLeft(), self.curX, self.curY)

        elif key == Qt.Key_Space:
            self.dropDown()

        elif key == Qt.Key_D:
            self.oneLineDown()

        else:
            super(Board, self).keyPressEvent(event)


    def timerEvent(self, event):
        '''handles timer event'''

        if event.timerId() == self.timer.timerId():

            if self.isWaitingAfterLine:
                self.isWaitingAfterLine = False
                self.newPiece()
            else:
                self.oneLineDown()

        else:
            super(Board, self).timerEvent(event)


    def clearBoard(self):
        '''clears shapes from the board'''

        for i in range(Board.BoardHeight * Board.BoardWidth):
            self.board.append(Tetrominoe.NoShape)


    def dropDown(self):
        '''drops down a shape'''

        newY = self.curY

        while newY > 0:

            if not self.tryMove(self.curPiece, self.curX, newY - 1):
                break

            newY -= 1

        self.pieceDropped()


    def oneLineDown(self):
        '''goes one line down with a shape'''

        if not self.tryMove(self.curPiece, self.curX, self.curY - 1):
            self.pieceDropped()


    def pieceDropped(self):
        '''after dropping shape, remove full lines and create new shape'''

        for i in range(4):

            x = self.curX + self.curPiece.x(i)
            y = self.curY - self.curPiece.y(i)
            self.setShapeAt(x, y, self.curPiece.shape())

        self.removeFullLines()

        if not self.isWaitingAfterLine:
            self.newPiece()


    def removeFullLines(self):
        '''removes all full lines from the board'''

        numFullLines = 0
        rowsToRemove = []

        for i in range(Board.BoardHeight):

            n = 0
            for j in range(Board.BoardWidth):
                if not self.shapeAt(j, i) == Tetrominoe.NoShape:
                    n = n + 1

            if n == 10:
                rowsToRemove.append(i)

        rowsToRemove.reverse()


        for m in rowsToRemove:

            for k in range(m, Board.BoardHeight):
                for l in range(Board.BoardWidth):
                        self.setShapeAt(l, k, self.shapeAt(l, k + 1))

        numFullLines = numFullLines + len(rowsToRemove)

        if numFullLines > 0:

            self.numLinesRemoved = self.numLinesRemoved + numFullLines
            self.msg2Statusbar.emit(str(self.numLinesRemoved))

            self.isWaitingAfterLine = True
            self.curPiece.setShape(Tetrominoe.NoShape)
            self.update()


    def newPiece(self):
        '''creates a new shape'''

        self.curPiece = Shape()
        self.curPiece.setRandomShape()
        self.curX = Board.BoardWidth // 2 + 1
        self.curY = Board.BoardHeight - 1 + self.curPiece.minY()

        if not self.tryMove(self.curPiece, self.curX, self.curY):

            self.curPiece.setShape(Tetrominoe.NoShape)
            self.timer.stop()
            self.isStarted = False
            self.msg2Statusbar.emit("Game over")



    def tryMove(self, newPiece, newX, newY):
        '''tries to move a shape'''

        for i in range(4):

            x = newX + newPiece.x(i)
            y = newY - newPiece.y(i)

            if x < 0 or x >= Board.BoardWidth or y < 0 or y >= Board.BoardHeight:
                return False

            if self.shapeAt(x, y) != Tetrominoe.NoShape:
                return False

        self.curPiece = newPiece
        self.curX = newX
        self.curY = newY
        self.update()

        return True


    def drawSquare(self, painter, x, y, shape):
        '''draws a square of a shape'''        

        colorTable = [0x000000, 0xCC6666, 0x66CC66, 0x6666CC,
                      0xCCCC66, 0xCC66CC, 0x66CCCC, 0xDAAA00]

        color = QColor(colorTable[shape])
        painter.fillRect(x + 1, y + 1, self.squareWidth() - 2, 
            self.squareHeight() - 2, color)

        painter.setPen(color.lighter())
        painter.drawLine(x, y + self.squareHeight() - 1, x, y)
        painter.drawLine(x, y, x + self.squareWidth() - 1, y)

        painter.setPen(color.darker())
        painter.drawLine(x + 1, y + self.squareHeight() - 1,
            x + self.squareWidth() - 1, y + self.squareHeight() - 1)
        painter.drawLine(x + self.squareWidth() - 1, 
            y + self.squareHeight() - 1, x + self.squareWidth() - 1, y + 1)


class Tetrominoe(object):

    NoShape = 0
    ZShape = 1
    SShape = 2
    LineShape = 3
    TShape = 4
    SquareShape = 5
    LShape = 6
    MirroredLShape = 7


class Shape(object):

    coordsTable = (
        ((0, 0),     (0, 0),     (0, 0),     (0, 0)),
        ((0, -1),    (0, 0),     (-1, 0),    (-1, 1)),
        ((0, -1),    (0, 0),     (1, 0),     (1, 1)),
        ((0, -1),    (0, 0),     (0, 1),     (0, 2)),
        ((-1, 0),    (0, 0),     (1, 0),     (0, 1)),
        ((0, 0),     (1, 0),     (0, 1),     (1, 1)),
        ((-1, -1),   (0, -1),    (0, 0),     (0, 1)),
        ((1, -1),    (0, -1),    (0, 0),     (0, 1))
    )

    def __init__(self):

        self.coords = [[0,0] for i in range(4)]
        self.pieceShape = Tetrominoe.NoShape

        self.setShape(Tetrominoe.NoShape)


    def shape(self):
        '''returns shape'''

        return self.pieceShape


    def setShape(self, shape):
        '''sets a shape'''

        table = Shape.coordsTable[shape]

        for i in range(4):
            for j in range(2):
                self.coords[i][j] = table[i][j]

        self.pieceShape = shape


    def setRandomShape(self):
        '''chooses a random shape'''

        self.setShape(random.randint(1, 7))


    def x(self, index):
        '''returns x coordinate'''

        return self.coords[index][0]


    def y(self, index):
        '''returns y coordinate'''

        return self.coords[index][1]


    def setX(self, index, x):
        '''sets x coordinate'''

        self.coords[index][0] = x


    def setY(self, index, y):
        '''sets y coordinate'''

        self.coords[index][1] = y


    def minX(self):
        '''returns min x value'''

        m = self.coords[0][0]
        for i in range(4):
            m = min(m, self.coords[i][0])

        return m


    def maxX(self):
        '''returns max x value'''

        m = self.coords[0][0]
        for i in range(4):
            m = max(m, self.coords[i][0])

        return m


    def minY(self):
        '''returns min y value'''

        m = self.coords[0][1]
        for i in range(4):
            m = min(m, self.coords[i][1])

        return m


    def maxY(self):
        '''returns max y value'''

        m = self.coords[0][1]
        for i in range(4):
            m = max(m, self.coords[i][1])

        return m


    def rotateLeft(self):
        '''rotates shape to the left'''

        if self.pieceShape == Tetrominoe.SquareShape:
            return self

        result = Shape()
        result.pieceShape = self.pieceShape

        for i in range(4):

            result.setX(i, self.y(i))
            result.setY(i, -self.x(i))

        return result


    def rotateRight(self):
        '''rotates shape to the right'''

        if self.pieceShape == Tetrominoe.SquareShape:
            return self

        result = Shape()
        result.pieceShape = self.pieceShape

        for i in range(4):

            result.setX(i, -self.y(i))
            result.setY(i, self.x(i))

        return result


if __name__ == '__main__':

    app = QApplication([])
    tetris = Tetris()    
    sys.exit(app.exec_())
```










# 扑克牌


一张扑克牌有自己的花色和数值。
一副扑克牌有4种花色和13张不同的值，还有两个大小王，共54张，牌面分为正面和背面。

扑克牌的常规操作：亮牌，抽一张牌，洗牌，发牌，码牌，出牌

扑克牌的玩法：判断玩法


```java


//扑克牌的操作
public class Hello {
    public static void main(String[] args) {
        aSuitPoker sp = new aSuitPoker();
        for (Poker p : sp.shuffle()) {
            System.out.println(p.getCard());
        }
    }
}

class aSuitPoker {
    static final Poker[] POKER = new Poker[55];
    //黑桃 spade 红心 heart 草花 club 方块 diamond
    static final String[] types = {"spade", "heart", "club", "diamond"};

    static {
        POKER[0] = new Poker("background", 0);
        int count = 0;
        for (int i = 0; i < 4; i++) {
            for (int j = 1; j <= 13; j++) {
                count++;
                POKER[count] = new Poker(types[i], j);
            }
        }
        POKER[53] = new Poker("JokerColor", 0);
        POKER[54] = new Poker("JokerBlack", 0);
    }

    //随机抽出一张扑克
    public static Poker randomPoker() {
        return POKER[(int) (Math.random() * 54) + 1];
    }

    //展示整套扑克牌
    public static void showAll() {
        for (Poker p : POKER) {
            System.out.println(p.getType() + p.getValue() + "\t" + p);
        }
    }

    //洗牌，返回一套乱序的Poker[54]
    public Poker[] shuffle() {
        Poker[] poker = new Poker[54];
        Poker temp = null;
        for (int i = 0; i < poker.length; i++) {
            poker[i] = POKER[i + 1];
        }
        for (int i = 0; i < 500; i++) {
            int a = (int) (Math.random() * 54);
            int b = (int) (Math.random() * 54);
            temp = poker[a];
            poker[a] = poker[b];
            poker[b] = temp;
        }
        return poker;
    }
}

class Poker {
    public String type;
    public int value;

    public Poker() {
    }

    public Poker(String type, int value) {
        this.type = type;
        this.value = value;
    }

    public String getValue() {
        String val = "";
        switch (value) {
            case 1:
                val = "A";
                break;
            case 11:
                val = "J";
                break;
            case 12:
                val = "Q";
                break;
            case 13:
                val = "K";
                break;
            default:
                val = String.valueOf(value);
                break;
        }
        return val;
    }

//    public void setValue(int value) {this.value = value;}
//    public void setType(String type) {this.type = type;}

    public String getType() {
        String color = "";
        //黑桃 spade 红心 heart 草花 club 方块 diamond
        switch (type) {
            case "background":
                color = "背面";
                break;
            case "spade":
                color = "黑桃";
                break;
            case "heart":
                color = "红心";
                break;
            case "club":
                color = "梅花";
                break;
            case "diamond":
                color = "方块";
                break;
            case "JokerColor":
                color = "大王";
                break;
            case "JokerBlack":
                color = "小王";
                break;
            default:
                color = "未知";
                break;
        }
        return color;
    }

    public String getCard() {
        return getType() + getValue();
    }

    public String toString() {
        return "Poker{" +
                "type='" + type + '\'' +
                ", value=" + value +
                '}';
    }
}


```








# snake

贪吃蛇





```java
/*snake.java
*/
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;

public class Snake {
	private Node head = null;
	private Node tail = null;
	private int size = 0;
	
	private Node n = new Node(20, 30, Dir.L);
	private Yard y;
	
	public Snake(Yard y) {
		head = n;
		tail = n;
		size = 1;
		this.y = y;
	}
	
	public void addToTail() {
		Node node = null;
		switch(tail.dir) {
		case L :
			node = new Node(tail.row, tail.col + 1, tail.dir);
			break;
		case U :
			node = new Node(tail.row + 1, tail.col, tail.dir);
			break;
		case R :
			node = new Node(tail.row, tail.col - 1, tail.dir);
			break;
		case D :
			node = new Node(tail.row - 1, tail.col, tail.dir);
			break;
		}
		tail.next = node;
		node.prev = tail;
		tail = node;
		size ++;
	}
	
	public void addToHead() {
		Node node = null;
		switch(head.dir) {
		case L :
			node = new Node(head.row, head.col - 1, head.dir);
			break;
		case U :
			node = new Node(head.row - 1, head.col, head.dir);
			break;
		case R :
			node = new Node(head.row, head.col + 1, head.dir);
			break;
		case D :
			node = new Node(head.row + 1, head.col, head.dir);
			break;
		}
		node.next = head;
		head.prev = node;
		head = node;
		size ++;
	}
	
	public void draw(Graphics g) {
		if(size <= 0) return;
		move();
		for(Node n = head; n != null; n = n.next) {
			n.draw(g);
		}
	}
	
	private void move() {
		addToHead();
		deleteFromTail();
		checkDead();
	}

	private void checkDead() {
		if(head.row < 2 || head.col < 0 || head.row > Yard.ROWS || head.col > Yard.COLS)  {
			y.stop();
		}
		
		for(Node n = head.next; n != null; n = n.next) {
			if(head.row == n.row && head.col == n.col) {
				y.stop();
			}
		}
	}

	private void deleteFromTail() {
		if(size == 0) return;
		tail = tail.prev;
		tail.next = null;
		
	}

	private class Node {
		int w = Yard.BLOCK_SIZE;
		int h = Yard.BLOCK_SIZE;
		int row , col;
		Dir dir = Dir.L;
		Node next = null;
		Node prev = null;
		
		Node(int row, int col, Dir dir) {
			this.row = row;
			this.col = col;
			this.dir = dir;
		}
		
		void draw(Graphics g) {
			Color c = g.getColor();
			g.setColor(Color.BLACK);
			g.fillRect(Yard.BLOCK_SIZE * col, Yard.BLOCK_SIZE * row, w, h);
			g.setColor(c);
		}
	}
	
	public void eat(Egg e) {
		if(this.getRect().intersects(e.getRect())) {
			e.reAppear();
			this.addToHead();
			y.setScore(y.getScore() + 5);
		}
	}
	
	private Rectangle getRect() {
		return new Rectangle(Yard.BLOCK_SIZE * head.col, Yard.BLOCK_SIZE * head.row, head.w, head.h);
	}
	
	public void keyPressed(KeyEvent e) {
		int key = e.getKeyCode();
		switch(key) {
		case KeyEvent.VK_LEFT :
			if(head.dir != Dir.R)
				head.dir = Dir.L;
			break;
		case KeyEvent.VK_UP :
			if(head.dir != Dir.D)
				head.dir = Dir.U;
			break;
		case KeyEvent.VK_RIGHT :
			if(head.dir != Dir.L)
				head.dir = Dir.R;
			break;
		case KeyEvent.VK_DOWN :
			if(head.dir != Dir.U)
				head.dir = Dir.D;
			break;
		}
	}
}
```


```java
/*Yard.java
*/
import java.awt.Color;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class Yard extends Frame {

	PaintThread paintThread = new PaintThread();
	private boolean gameOver = false; //游戏是否结束
	
	/**
	 * 行数
	 */
	public static final int ROWS = 30;
	public static final int COLS = 30;
	public static final int BLOCK_SIZE = 15;
	
	private Font fontGameOver = new Font("宋体", Font.BOLD, 50);
	
	private int score = 0;
	
	Snake s = new Snake(this);
	Egg e = new Egg();
	
	Image offScreenImage = null;
	
	public void launch() {
		this.setLocation(200, 200);
		this.setSize(COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
		this.addWindowListener(new WindowAdapter() {

			@Override
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
			
		});
		this.setVisible(true);
		this.addKeyListener(new KeyMonitor());
		
		new Thread(paintThread).start();
	}
	
	public static void main(String[] args) {
		new Yard().launch();
	}
	
	public void stop() {
		gameOver = true;
	}
	
	@Override
	public void paint(Graphics g) {
		Color c = g.getColor();
		g.setColor(Color.GRAY);
		g.fillRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
		g.setColor(Color.DARK_GRAY);
		//画出横线
		for(int i=1; i<ROWS; i++) {
			g.drawLine(0, BLOCK_SIZE * i, COLS * BLOCK_SIZE, BLOCK_SIZE * i);
		}
		for(int i=1; i<COLS; i++) {
			g.drawLine(BLOCK_SIZE * i, 0, BLOCK_SIZE * i, BLOCK_SIZE * ROWS);
		}
		
		g.setColor(Color.YELLOW);
		g.drawString("score:" + score, 10, 60);
		
		if(gameOver) {
			g.setFont(fontGameOver);
			g.drawString("游戏结束", 120, 180);
			
			paintThread.pause();
		}
		
		g.setColor(c);
		
		s.eat(e);
		e.draw(g);
		s.draw(g);
		
		
	}
	
	@Override
	public void update(Graphics g) {
		if(offScreenImage == null) {
			offScreenImage = this.createImage(COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
		}
		Graphics gOff = offScreenImage.getGraphics();
		paint(gOff);
		g.drawImage(offScreenImage, 0, 0,  null);
	}
	
	private class PaintThread implements Runnable {
		private boolean running = true;
		private boolean pause = false;
		public void run() {
			while(running) {
				if(pause) continue; 
				else repaint();
				
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		
		public void pause() {
			this.pause = true;
		}
		
		public void reStart() {
			this.pause = false;
			s = new Snake(Yard.this);
			gameOver = false;
		}
		
		public void gameOver() {
			running = false;
		}
		
	}
	
	private class KeyMonitor extends KeyAdapter {

		@Override
		public void keyPressed(KeyEvent e) {
			int key = e.getKeyCode();
			if(key == KeyEvent.VK_F2) {
				paintThread.reStart();
			}
			s.keyPressed(e);
		}
		
	}
	
	public int getScore() {
		return score;
	}

	
	public void setScore(int score) {
		this.score = score;
	}
}
```


```java
/*Egg.java
*/
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.Random;

public class Egg {
	int row, col;
	int w = Yard.BLOCK_SIZE;
	int h = Yard.BLOCK_SIZE;
	private static Random r = new Random();
	private Color color = Color.GREEN;

	public Egg(int row, int col) {
		this.row = row;
		this.col = col;
	}
	
	public Egg() {
		this(r.nextInt(Yard.ROWS-2) + 2, r.nextInt(Yard.COLS));
	}
	
	public void reAppear() {
		this.row = r.nextInt(Yard.ROWS-2) + 2;
		this.col = r.nextInt(Yard.COLS);
	}
	
	public Rectangle getRect() {
		return new Rectangle(Yard.BLOCK_SIZE * col, Yard.BLOCK_SIZE * row, w, h);
	}
	
	public void draw(Graphics g) {
		Color c = g.getColor();
		g.setColor(color);
		g.fillOval(Yard.BLOCK_SIZE * col, Yard.BLOCK_SIZE * row, w, h);
		g.setColor(c);
		if(color == Color.GREEN) color = Color.RED;
		else color = Color.GREEN;
	}

	public int getCol() {
		return col;
	}

	public void setCol(int col) {
		this.col = col;
	}

	public int getRow() {
		return row;
	}

	public void setRow(int row) {
		this.row = row;
	}
	
}
```


```java
/*Dir.java
*/
public enum Dir {
	L, U, R, D
}
```













# 围棋的起源

围棋是一个智力游戏，起源于中国。下围棋对人脑的智力开发很有帮助，可增强一个人的计算能力、记忆力、创意能力、思想能力、判断能力，也能提高人对注意力的控制能力。

围棋是一个智力游戏，起源于中国。

相传，上古时期尧都平阳，平息协和各部落方国以后，农耕生产和人民生活呈现出一派繁荣兴旺的景象。但有一件事情却让帝尧很忧虑，散宜氏所生子丹朱虽长大成人，十几岁了却不务正业，游手好闲，聚朋嚣讼斗狠，经常招惹祸端。大禹治平洪水不久，丹朱坐上木船让人推着在汾河西岸的湖泊里荡来荡去，高兴地连饭也顾不上吃了，家也不回了，母亲的话也不听了。散宜氏对帝尧说：“尧啊，你只顾忙于处理百姓大事，儿子丹朱越来越不像话了，你也不管管，以后怎么能替你干大事呀!”帝尧沉默良久，心想：要使丹朱归善，必先稳其性，娱其心，教他学会几样本领才行。便对散宜氏说：“你让人把丹朱找回来，再让他带上弓箭到平山顶上去等我。”

这时丹朱正在汾河滩和一群人戏水，忽见父亲的几个卫士，不容分说，强拉扯着他上了平山，把弓箭塞到他手里，对他说：“你父帝和母亲叫你来山上打猎，你可得给父母装人啊。”丹朱心想：射箭的本领我又没学会，咋打猎呢?丹朱看山上荆棘满坡，望天空白云朵朵，哪有什么兔子、飞鸟呢?这明明是父亲母亲难为自己!“哼，打猎我就是不学，看父母能把我怎么样!”卫士们好说歹劝，丹朱就是坐着动也不动。一伙人正吵嚷着，帝尧从山下被诗人搀扶着上来了，衣服也被挂破了。看到父帝气喘吁吁的样子，丹朱心里不免有些心软，只好向父帝作揖拜跪，唱个喏：“父帝这把年纪要爬这么高的山，让儿上山打猎，不知从何说起?”帝尧擦了把汗，坐到一块石上，问：“不肖子啊，你也不小了，十七、八岁了，还不走正道，猎也不会打，等着将来饿死吗?你看山下这么广阔的土地，这么好的山河，你就不替父帝操一点心，把土地、山河、百姓治理好吗?”丹朱眨了眨眼晴，说：“兔子跑得快，鸟儿飞得高，这山上无兔子，天上无飞鸟，叫我打啥哩。天下百姓都听你的话，土地山河也治理好了，哪用儿子再替父帝操心呀。”帝尧一听丹朱说出如此不思上进、无心治业的话，叹了一口气说：“你不愿学打猎，就学行兵征战的石子棋吧，石子棋学会了，用处也大着哩。”丹朱听父帝不叫他打猎，改学下石子棋，心里稍有转意，“下石子棋还不容易吗?坐下一会儿就学会了。”丹朱扔掉了箭，要父亲立即教他。帝尧说：“哪有一朝一夕就能学会的东西，你只要肯学就行。”说着拾起箭来，蹲下身，用箭头在一块平坡山石上用力刻画了纵横十几道方格子，让卫士们捡来一大堆山石子，又分给丹朱一半，手把着手地将自己在率领部落征战过程中如何利用石子表示前进后退的作战谋略传授讲解给丹朱。丹朱此时倒也听得进去，显得有了耐心。直至太阳要落山的时候，帝尧教子下棋还是那样的尽心尽力。在卫士们的催促下，父子们才下了平山，在乎水泉里洗了把脸，回到平阳都城。

此后一段时日，丹朱学棋很专心，也不到外边游逛，散宜氏心里踏实些。帝尧对散宜氏说：“石子棋包含着很深的治理百姓、军队、山河的道理，丹朱如果真的回心转意，明白了这些道理，接替我的帝位，是自然的事情啊。”孰料，丹朱棋还没学深学透，却听信先前那帮人的坏话，觉得下棋太束缚人，一点自由也没有，还得费脑子，犯以前的老毛病，终日朋淫生非，甚至想用诡计夺取父帝的位置，散宜氏痛心不已，大病一场，怏怏而终。帝尧也十分伤心，把丹朱迁送到南方，再也不想看到丹朱，还把帝位禅让给经过他三年严格考察认为不但有德且有智有才的虞舜。虞舜也学帝尧的样子，用石子棋教子商均。以后的陶器上便产生围棋方格的图形，史书便有“尧造围棋，以教丹朱”的记载。今龙祠乡晋掌村西山便有棋盘岭围棋石刻图形遗迹

今日，在亚洲的围棋人口有数千万人，在欧美国家也有不少人会下围棋。

围棋的规则十分简单，却拥有十分广大的空间可以落子，使得围棋变化多端，比中国象棋更为复杂。这就是围棋的魅力所在。下一盘围棋的时间没有规定，快则五分钟，慢则要几天，多数时候下一盘棋需要一到二个小时。

下围棋对人脑的智力开发很有帮助，可增强一个人的计算能力、记忆力、创意能力、思想能力、判断能力，也能提高人对注意力的控制能力。下围棋也会对小孩子起到积极作用，使他们能更好的分析事物。




# 图形编程


画图 河图洛书
记账软件，专注软件，待办软件

写一个代码分析的程序，比如判断一天写了多少代码，有几个参考值。判断这个代码中建立了哪些变量，用了哪些头文件，写了哪些函数，函数输入什么输出什么做了哪些操作，产生了什么影响起了什么作用。



写一个简单的计算器，功能，能够使用脚本命令，像python解释器那样去解析代码并判断脚本，最后得到一个值
